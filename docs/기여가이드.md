# 기여 가이드

> 6502 BASIC JavaScript 에뮬레이터 프로젝트 기여 방법

## 🎯 기여 방법 개요

6502 BASIC JavaScript 에뮬레이터 프로젝트에 관심을 가져주셔서 감사합니다! 이 문서는 프로젝트에 효과적으로 기여할 수 있는 방법을 안내합니다.

## 📋 목차

1. [기여할 수 있는 영역](#기여할-수-있는-영역)
2. [개발 환경 설정](#개발-환경-설정)
3. [기여 프로세스](#기여-프로세스)
4. [코딩 표준](#코딩-표준)
5. [테스트 가이드라인](#테스트-가이드라인)
6. [문서화 가이드라인](#문서화-가이드라인)
7. [이슈 리포트](#이슈-리포트)
8. [Pull Request 가이드라인](#pull-request-가이드라인)
9. [커뮤니티 가이드라인](#커뮤니티-가이드라인)

## 🎨 기여할 수 있는 영역

### 🔧 코드 개발

#### 1. CPU 에뮬레이터 개선
- **난이도**: ⭐⭐⭐⭐⭐ (고급)
- **필요 기술**: 6502 어셈블리, TypeScript, 컴퓨터 아키텍처
- **예시 작업**:
  - 6502 명령어 구현
  - 주소 지정 모드 최적화
  - 사이클 정확도 개선
  - 인터럽트 처리 구현

```typescript
// 예시: 새로운 명령어 구현
export class InstructionLDA implements CPUInstruction {
  execute(cpu: CPU6502): void {
    const value = cpu.fetchOperand(this.addressingMode);
    cpu.registers.A = value;
    cpu.setFlags(value);
  }
}
```

#### 2. BASIC 인터프리터 확장
- **난이도**: ⭐⭐⭐⭐ (중상급)
- **필요 기술**: TypeScript, 컴파일러 이론, BASIC 언어
- **예시 작업**:
  - 새로운 BASIC 명령어 추가
  - 표현식 파서 개선
  - 변수 관리 최적화
  - 에러 처리 강화

```typescript
// 예시: 새로운 BASIC 명령어 구현
export class PrintStatement implements Statement {
  execute(interpreter: BasicInterpreter): void {
    const values = this.expressions.map(expr => 
      interpreter.evaluate(expr)
    );
    interpreter.output(values.join(' '));
  }
}
```

#### 3. 수학 라이브러리 구현
- **난이도**: ⭐⭐⭐ (중급)
- **필요 기술**: TypeScript, 수학, 부동소수점 연산
- **예시 작업**:
  - 삼각함수 정확도 개선
  - 부동소수점 연산 최적화
  - 새로운 수학 함수 추가

#### 4. 사용자 인터페이스 개발
- **난이도**: ⭐⭐ (초중급)
- **필요 기술**: HTML, CSS, JavaScript, 웹 디자인
- **예시 작업**:
  - 터미널 인터페이스 개선
  - 코드 에디터 기능 추가
  - 디버깅 도구 UI 구현
  - 반응형 디자인 적용

### 📚 문서 개선

#### 1. 사용자 문서
- **난이도**: ⭐ (초급)
- **필요 기술**: 한국어, BASIC 언어 지식
- **예시 작업**:
  - 튜토리얼 작성
  - 예제 프로그램 추가
  - FAQ 문서 작성
  - 사용자 가이드 개선

#### 2. 개발자 문서
- **난이도**: ⭐⭐ (초중급)
- **필요 기술**: 기술 문서 작성, 소프트웨어 아키텍처
- **예시 작업**:
  - API 문서 작성
  - 아키텍처 다이어그램 작성
  - 코드 주석 개선
  - 개발 가이드 업데이트

### 🧪 품질 보증

#### 1. 테스트 작성
- **난이도**: ⭐⭐⭐ (중급)
- **필요 기술**: Jest, TypeScript, 테스트 방법론
- **예시 작업**:
  - 단위 테스트 추가
  - 통합 테스트 작성
  - E2E 테스트 구현
  - 성능 테스트 개발

#### 2. 버그 수정
- **난이도**: ⭐⭐ ~ ⭐⭐⭐⭐ (초중급 ~ 고급)
- **필요 기술**: 디버깅, TypeScript, 관련 도메인 지식
- **예시 작업**:
  - 이슈 재현 및 수정
  - 엣지 케이스 처리
  - 성능 이슈 해결
  - 호환성 문제 수정

### 🎨 디자인 및 UX

#### 1. 시각적 디자인
- **난이도**: ⭐⭐ (초중급)
- **필요 기술**: CSS, 디자인 감각, 레트로 컴퓨팅 지식
- **예시 작업**:
  - 레트로 스타일 테마 제작
  - 아이콘 디자인
  - 색상 팔레트 개선
  - 타이포그래피 최적화

#### 2. 사용성 개선
- **난이도**: ⭐⭐ (초중급)
- **필요 기술**: UX 디자인, 사용자 연구
- **예시 작업**:
  - 사용자 플로우 개선
  - 접근성 향상
  - 모바일 최적화
  - 키보드 단축키 추가

## 🛠️ 개발 환경 설정

### 1. 저장소 포크 및 클론

```bash
# 1. GitHub에서 저장소를 포크합니다
# 2. 포크된 저장소를 로컬에 클론합니다
git clone https://github.com/your-username/6502-basic-js.git
cd 6502-basic-js/jsbasic

# 3. 원본 저장소를 upstream으로 추가합니다
git remote add upstream https://github.com/original-owner/6502-basic-js.git
```

### 2. 개발 환경 구성

```bash
# Bun 설치 (https://bun.sh/)
curl -fsSL https://bun.sh/install | bash

# 의존성 설치
bun install

# 개발 서버 시작
bun run dev

# 테스트 실행
bun run test
```

### 3. VS Code 설정

`.vscode/settings.json`:
```json
{
  "editor.formatOnSave": true,
  "editor.defaultFormatter": "esbenp.prettier-vscode",
  "typescript.preferences.importModuleSpecifier": "relative",
  "editor.codeActionsOnSave": {
    "source.fixAll.eslint": true
  }
}
```

## 🔄 기여 프로세스

### 1. 이슈 확인 및 할당

```bash
# 최신 코드로 업데이트
git checkout main
git pull upstream main

# 새 기능 브랜치 생성
git checkout -b feature/your-feature-name

# 또는 버그 수정 브랜치
git checkout -b fix/bug-description
```

### 2. 개발 작업

#### 개발 중 체크리스트
- [ ] 코드 작성 전 관련 테스트 작성 (TDD)
- [ ] TypeScript 타입 안전성 확보
- [ ] 기존 테스트 통과 확인
- [ ] 새로운 기능에 대한 테스트 추가
- [ ] 코드 문서화 (JSDoc 주석)
- [ ] 린터 규칙 준수

#### 정기적인 동기화

```bash
# 정기적으로 upstream과 동기화
git fetch upstream
git merge upstream/main

# 충돌 해결 후
git push origin feature/your-feature-name
```

### 3. 제출 준비

```bash
# 최종 테스트 실행
bun run test
bun run lint
bun run build

# 변경사항 커밋
git add .
git commit -m "feat: 새로운 기능 구현

- 기능 A 추가
- 버그 B 수정
- 테스트 C 추가

closes #123"

# 원격 저장소에 푸시
git push origin feature/your-feature-name
```

## 📋 코딩 표준

### 1. TypeScript 스타일 가이드

```typescript
// ✅ 좋은 예제
interface CPUInstruction {
  readonly opcode: number;
  readonly mnemonic: string;
  readonly cycles: number;
  readonly addressingMode: AddressingMode;
  
  execute(cpu: CPU6502): void;
}

class LDAInstruction implements CPUInstruction {
  constructor(
    public readonly opcode: number,
    public readonly addressingMode: AddressingMode
  ) {}
  
  public execute(cpu: CPU6502): void {
    const value = cpu.fetchOperand(this.addressingMode);
    cpu.registers.A = value;
    cpu.setZeroAndNegativeFlags(value);
  }
}

// ❌ 나쁜 예제
class lda {  // 클래스명은 PascalCase
  op: any;   // any 타입 지양
  exec() {   // 메서드 목적 불명확
    // ...
  }
}
```

### 2. 네이밍 규칙

```typescript
// 변수 및 함수: camelCase
const memorySize = 65536;
function executeInstruction() {}

// 클래스: PascalCase  
class CPU6502 {}
class BasicInterpreter {}

// 상수: UPPER_SNAKE_CASE
const MAX_MEMORY_SIZE = 65536;
const DEFAULT_CPU_FREQ = 1_000_000;

// 인터페이스: PascalCase (I 접두사 지양)
interface MemoryManager {}
interface CPUState {}

// 타입: PascalCase
type AddressingMode = 'immediate' | 'absolute' | 'zeroPage';

// 열거형: PascalCase, 값은 UPPER_SNAKE_CASE
enum CPUFlag {
  CARRY = 0x01,
  ZERO = 0x02,
  INTERRUPT = 0x04
}
```

### 3. 파일 구조 규칙

```typescript
// 파일 상단: imports
import { CPU6502 } from '@/cpu/cpu';
import { MemoryManager } from '@/memory/memory';
import type { CPUInstruction, AddressingMode } from '@/types';

// 타입 정의
interface LocalInterface {
  // ...
}

// 상수 정의
const LOCAL_CONSTANT = 42;

// 클래스 정의
export class ExampleClass {
  // 멤버 변수 (private 먼저)
  private readonly memory: MemoryManager;
  public readonly name: string;
  
  // 생성자
  constructor(memory: MemoryManager, name: string) {
    this.memory = memory;
    this.name = name;
  }
  
  // public 메서드
  public execute(): void {
    // ...
  }
  
  // private 메서드
  private helper(): void {
    // ...
  }
}

// 기본 export
export default ExampleClass;
```

### 4. 주석 및 문서화

```typescript
/**
 * 6502 CPU의 LDA (Load Accumulator) 명령어 구현
 * 
 * @example
 * ```typescript
 * const instruction = new LDAInstruction(0xA9, AddressingMode.IMMEDIATE);
 * instruction.execute(cpu);
 * ```
 */
export class LDAInstruction implements CPUInstruction {
  /**
   * LDA 명령어 생성자
   * 
   * @param opcode - 명령어 오피코드 (0xA9, 0xA5, 등)
   * @param addressingMode - 주소 지정 모드
   */
  constructor(
    public readonly opcode: number,
    public readonly addressingMode: AddressingMode
  ) {}
  
  /**
   * 명령어 실행
   * 
   * 지정된 주소 지정 모드에 따라 값을 읽어서 누산기에 로드합니다.
   * Z (Zero)와 N (Negative) 플래그가 결과에 따라 설정됩니다.
   * 
   * @param cpu - CPU 인스턴스
   * 
   * @throws {CPUError} 잘못된 메모리 주소 접근 시
   */
  public execute(cpu: CPU6502): void {
    const value = cpu.fetchOperand(this.addressingMode);
    cpu.registers.A = value;
    cpu.setZeroAndNegativeFlags(value);
  }
}
```

## 🧪 테스트 가이드라인

### 1. 테스트 구조

```typescript
describe('CPU6502 LDA Instruction', () => {
  let cpu: CPU6502;
  let memory: MemoryManager;
  
  beforeEach(() => {
    memory = new MemoryManager();
    cpu = new CPU6502(memory);
    cpu.reset();
  });
  
  afterEach(() => {
    // 정리 작업
  });
  
  describe('immediate addressing mode', () => {
    it('누산기에 즉시값을 로드해야 함', () => {
      // Given: LDA #$42 설정
      memory.write(0x0000, 0xA9); // LDA immediate
      memory.write(0x0001, 0x42); // 값
      
      // When: 명령어 실행
      const cycles = cpu.step();
      
      // Then: 결과 검증
      expect(cpu.registers.A).toBe(0x42);
      expect(cpu.registers.PC).toBe(0x0002);
      expect(cpu.getFlag(CPUFlag.ZERO)).toBe(false);
      expect(cpu.getFlag(CPUFlag.NEGATIVE)).toBe(false);
      expect(cycles).toBe(2);
    });
    
    it('0을 로드할 때 Zero 플래그가 설정되어야 함', () => {
      // Given
      memory.write(0x0000, 0xA9); // LDA immediate
      memory.write(0x0001, 0x00); // 0
      
      // When
      cpu.step();
      
      // Then
      expect(cpu.registers.A).toBe(0x00);
      expect(cpu.getFlag(CPUFlag.ZERO)).toBe(true);
      expect(cpu.getFlag(CPUFlag.NEGATIVE)).toBe(false);
    });
    
    it('음수를 로드할 때 Negative 플래그가 설정되어야 함', () => {
      // Given
      memory.write(0x0000, 0xA9); // LDA immediate
      memory.write(0x0001, 0x80); // -128 (0x80)
      
      // When
      cpu.step();
      
      // Then
      expect(cpu.registers.A).toBe(0x80);
      expect(cpu.getFlag(CPUFlag.ZERO)).toBe(false);
      expect(cpu.getFlag(CPUFlag.NEGATIVE)).toBe(true);
    });
  });
  
  describe('zero page addressing mode', () => {
    // 제로 페이지 테스트들...
  });
});
```

### 2. 테스트 범위 목표

- **단위 테스트**: 90% 이상 커버리지
- **통합 테스트**: 주요 워크플로우 100% 커버리지
- **E2E 테스트**: 사용자 시나리오 커버리지

### 3. 테스트 실행

```bash
# 모든 테스트 실행
bun run test

# 특정 파일 테스트
bun run test src/cpu/instructions.test.ts

# 커버리지 포함 테스트
bun run test --coverage

# 워치 모드
bun run test --watch
```

## 📚 문서화 가이드라인

### 1. README 업데이트

새로운 기능을 추가했다면 README.md를 업데이트해주세요:

```markdown
# 새로운 기능 섹션 추가
## 🆕 새로운 기능

### CPU 디버거
- 브레이크포인트 설정
- 단계별 실행
- 레지스터 모니터링

### 사용법
\`\`\`typescript
const debugger = new CPUDebugger(cpu);
debugger.setBreakpoint(0x1000);
debugger.step();
\`\`\`
```

### 2. API 문서 업데이트

새로운 클래스나 메서드를 추가했다면 API 문서를 업데이트해주세요:

```markdown
### `CPUDebugger` 클래스

CPU 디버깅 기능을 제공합니다.

#### 생성자
\`\`\`typescript
constructor(cpu: CPU6502)
\`\`\`

#### 주요 메서드

##### `setBreakpoint(address: number): void`
지정된 주소에 브레이크포인트를 설정합니다.
```

### 3. 코드 주석

```typescript
/**
 * CPU 디버거 클래스
 * 
 * 6502 CPU의 실행을 단계별로 추적하고 분석할 수 있는 디버깅 도구를 제공합니다.
 * 브레이크포인트, 워치포인트, 메모리 모니터링 등의 기능을 지원합니다.
 * 
 * @example
 * ```typescript
 * const debugger = new CPUDebugger(cpu);
 * debugger.setBreakpoint(0x1000);
 * debugger.on('breakpoint', (address) => {
 *   console.log(`브레이크포인트 도달: 0x${address.toString(16)}`);
 * });
 * ```
 */
export class CPUDebugger extends EventEmitter<DebuggerEvents> {
  // ...
}
```

## 🐛 이슈 리포트

### 1. 버그 리포트 템플릿

이슈를 생성할 때 다음 템플릿을 사용해주세요:

```markdown
## 🐛 버그 리포트

### 요약
간단하고 명확한 버그 설명

### 재현 단계
1. '...' 로 이동
2. '...' 클릭
3. '...' 입력
4. 에러 발생 확인

### 예상 동작
정상적으로 작동해야 하는 동작 설명

### 실제 동작
실제로 발생하는 문제 설명

### 스크린샷
가능하다면 스크린샷 첨부

### 환경 정보
- OS: [예: macOS 13.0]
- 브라우저: [예: Chrome 108]
- 버전: [예: v1.0.0]

### 추가 정보
기타 관련 정보나 컨텍스트
```

### 2. 기능 요청 템플릿

```markdown
## ✨ 기능 요청

### 기능 설명
명확하고 간결한 기능 설명

### 문제 상황
이 기능이 해결하는 문제나 필요성 설명

### 제안하는 해결방법
원하는 해결방법 설명

### 대안 방법
고려한 다른 대안들

### 추가 정보
기타 관련 정보나 컨텍스트
```

## 🔄 Pull Request 가이드라인

### 1. PR 제목 규칙

```
타입(범위): 간단한 설명

예시:
feat(cpu): 6502 BRK 명령어 구현
fix(basic): FOR 루프 파싱 오류 수정  
docs(readme): 설치 가이드 업데이트
test(memory): 메모리 관리 테스트 추가
refactor(ui): 터미널 컴포넌트 리팩터링
```

### 2. PR 설명 템플릿

```markdown
## 📋 변경 사항 요약
이 PR에서 변경된 내용을 간단히 설명

## 🎯 관련 이슈
- Closes #123
- Related to #456

## 📝 변경 내용
- [ ] 새로운 기능 추가
- [ ] 버그 수정
- [ ] 문서 업데이트
- [ ] 코드 리팩터링
- [ ] 테스트 추가

### 상세 변경 사항
1. 변경사항 1 설명
2. 변경사항 2 설명
3. ...

## 🧪 테스트
- [ ] 새로운 테스트 추가됨
- [ ] 기존 테스트 통과
- [ ] 수동 테스트 완료

### 테스트 방법
1. 테스트 단계 1
2. 테스트 단계 2
3. ...

## 📋 체크리스트
- [ ] 코드가 프로젝트 스타일 가이드를 따름
- [ ] 자체 검토 완료
- [ ] 코드에 필요한 주석 추가
- [ ] 관련 문서 업데이트
- [ ] 변경사항에 대한 테스트 추가
- [ ] 새로운/기존 테스트 통과
- [ ] 의존적인 변경사항 병합 완료

## 📷 스크린샷 (해당되는 경우)
UI 변경사항이 있다면 스크린샷 첨부

## ⚠️ 주의사항
리뷰어가 알아야 할 특별한 사항이나 주의점
```

### 3. PR 리뷰 프로세스

1. **자동 검사**: CI/CD 파이프라인이 자동으로 테스트 실행
2. **코드 리뷰**: 최소 1명의 메인테이너가 리뷰
3. **피드백 반영**: 요청된 변경사항 반영
4. **최종 승인**: 승인 후 메인 브랜치에 병합

### 4. 리뷰 가이드라인

#### 리뷰어를 위한 체크리스트

- [ ] 코드 품질 및 스타일 가이드 준수
- [ ] 타입 안전성 확보
- [ ] 성능상 문제점 없음
- [ ] 보안 취약점 없음
- [ ] 테스트 커버리지 적절함
- [ ] 문서 업데이트 적절함
- [ ] 하위 호환성 유지

#### 건설적인 피드백 작성법

```markdown
# ✅ 좋은 피드백
이 부분에서 메모리 누수가 발생할 수 있을 것 같습니다. 
이벤트 리스너를 정리하는 cleanup 함수를 추가하는 것이 어떨까요?

# ❌ 나쁜 피드백
이 코드는 잘못되었습니다.
```

## 🤝 커뮤니티 가이드라인

### 1. 행동 규범

#### 환영하는 행동
- 다른 관점과 경험에 대한 존중
- 건설적인 비판 제공 및 수용
- 커뮤니티 최선의 이익 추구
- 다른 커뮤니티 구성원에 대한 공감

#### 허용되지 않는 행동
- 성적, 차별적 언어나 이미지 사용
- 트롤링, 모욕적/경멸적 댓글, 개인 공격
- 공적/사적 괴롭힘
- 명시적 허락 없는 개인정보 공개

### 2. 소통 가이드라인

#### 이슈 및 토론
- 명확하고 서술적인 제목 사용
- 충분한 컨텍스트와 정보 제공
- 관련 있는 라벨과 마일스톤 추가
- 중복 이슈 생성 전 기존 이슈 검색

#### 코드 리뷰
- 코드에 대해 댓글, 개인에 대해서는 절대 안함
- 구체적이고 실행 가능한 피드백 제공
- 칭찬도 적절히 제공 (잘 작성된 코드에 대해)
- 질문 형태로 제안 ("~하는 것이 어떨까요?")

### 3. 멘토링 프로그램

#### 새로운 기여자를 위한 지원
- `good first issue` 라벨로 초보자 친화적 이슈 표시
- 상세한 구현 가이드 제공
- 코드 리뷰 시 교육적 피드백 제공
- 질문에 대한 친절하고 빠른 응답

#### 멘토가 되고 싶다면
1. 프로젝트에 3개 이상의 PR 병합
2. 커뮤니티 가이드라인 이해 및 준수
3. 멘토링 의사를 메인테이너에게 전달

## 🏆 기여자 인정

### 1. 기여자 목록
- `README.md`의 기여자 섹션에 추가
- 월간 기여자 하이라이트
- 연간 기여 어워드

### 2. 인정 기준
- **코드 기여**: PR 병합 시
- **문서 기여**: 문서 개선 PR 병합 시  
- **이슈 관리**: 유용한 버그 리포트나 기능 제안
- **커뮤니티 지원**: 다른 사용자 도움, 질문 답변

### 3. 특별 역할
- **Collaborator**: 지속적인 고품질 기여자
- **Maintainer**: 프로젝트 방향성 결정 참여
- **Documentation Lead**: 문서 관리 책임
- **Community Manager**: 커뮤니티 관리 및 지원

## 📞 연락처 및 지원

### 질문이나 도움이 필요하시면:

- **GitHub Issues**: 기술적 질문이나 버그 리포트
- **GitHub Discussions**: 일반적인 질문이나 아이디어 논의
- **이메일**: maintainer@example.com (긴급한 사항만)

### 실시간 소통:
- **Discord**: [프로젝트 디스코드 서버 링크]
- **Slack**: [프로젝트 슬랙 워크스페이스 링크]

---

다시 한 번 6502 BASIC JavaScript 에뮬레이터 프로젝트에 관심을 가져주셔서 감사합니다! 여러분의 기여가 이 프로젝트를 더욱 발전시키는 원동력이 됩니다. 

궁금한 점이나 도움이 필요한 일이 있으시면 언제든 연락해 주세요! 🚀