# 사용자 가이드

> 6502 BASIC JavaScript 에뮬레이터 사용법 완전 가이드

## 📋 목차

1. [빠른 시작](#빠른-시작)
2. [BASIC 언어 기초](#basic-언어-기초)
3. [프로그램 작성하기](#프로그램-작성하기)
4. [내장 명령어](#내장-명령어)
5. [수학 함수](#수학-함수)
6. [문자열 처리](#문자열-처리)
7. [파일 관리](#파일-관리)
8. [디버깅 도구](#디버깅-도구)
9. [고급 기능](#고급-기능)
10. [예제 프로그램](#예제-프로그램)

## 🚀 빠른 시작

### 첫 번째 프로그램

에뮬레이터에 접속하면 다음과 같은 화면을 볼 수 있습니다:

```
6502 BASIC COMPUTER
32767 BYTES FREE

READY.
```

이제 첫 번째 프로그램을 만들어 보겠습니다:

```basic
10 PRINT "안녕하세요, BASIC!"
RUN
```

결과:
```
안녕하세요, BASIC!
READY.
```

### 기본 명령어 익히기

```basic
NEW              # 새 프로그램 시작
LIST             # 현재 프로그램 보기
RUN              # 프로그램 실행
SAVE "HELLO"     # 프로그램 저장
LOAD "HELLO"     # 프로그램 불러오기
```

## 📖 BASIC 언어 기초

### 라인 번호

BASIC 프로그램의 각 줄은 라인 번호로 시작합니다:

```basic
10 PRINT "첫 번째 줄"
20 PRINT "두 번째 줄"
30 END
```

**라인 번호 규칙:**
- 1부터 65535까지 가능
- 오름차순으로 정렬
- 보통 10, 20, 30... 또는 100, 200, 300... 단위 사용

### 변수

#### 숫자 변수
```basic
10 A = 42
20 B = 3.14159
30 X1 = 100
40 TOTAL = A + B + X1
```

#### 문자열 변수 ($ 기호로 끝남)
```basic
10 NAME$ = "김철수"
20 MESSAGE$ = "안녕하세요"
30 FULL$ = MESSAGE$ + ", " + NAME$ + "!"
```

#### 배열 변수
```basic
10 DIM A(10)           # 숫자 배열 (0-10)
20 DIM B$(5)           # 문자열 배열 (0-5)
30 A(0) = 100
40 B$(1) = "HELLO"
```

### 데이터 타입

| 타입 | 설명 | 예제 | 범위 |
|------|------|------|------|
| 정수 | 정수 | `42`, `-100` | -32768 ~ 32767 |
| 실수 | 부동소수점 | `3.14`, `1.23E-4` | ±1.7E±38 |
| 문자열 | 문자 시퀀스 | `"HELLO"` | 최대 255자 |
| 배열 | 값들의 집합 | `A(5)`, `B$(10)` | 차원별 최대 255 |

## ✍️ 프로그램 작성하기

### 기본 입출력

#### PRINT 문 - 데이터 출력

```basic
# 기본 출력
10 PRINT "HELLO WORLD"

# 여러 값 출력
20 PRINT "이름:", "김철수", "나이:", 25

# 세미콜론으로 연결 (공백 없음)
30 PRINT "A"; "B"; "C"          # ABC

# 쉼표로 연결 (탭 구분)
40 PRINT "NAME", "AGE", "CITY"  # NAME    AGE    CITY

# 빈 줄 출력
50 PRINT

# 수식 출력
60 PRINT 2 + 3 * 4              # 14
```

#### INPUT 문 - 데이터 입력

```basic
10 INPUT "이름을 입력하세요: "; NAME$
20 INPUT "나이를 입력하세요: "; AGE
30 PRINT "안녕하세요, "; NAME$; "님!"
40 PRINT "나이는 "; AGE; "세이군요."
```

### 제어 구조

#### IF/THEN 조건문

```basic
# 기본 조건문
10 INPUT "숫자를 입력하세요: "; N
20 IF N > 0 THEN PRINT "양수입니다"
30 IF N = 0 THEN PRINT "영입니다"
40 IF N < 0 THEN PRINT "음수입니다"

# 복잡한 조건
50 IF N >= 10 AND N <= 20 THEN PRINT "10-20 사이입니다"

# GOTO와 함께 사용
60 IF N = 99 THEN GOTO 100
70 PRINT "계속 진행"
80 END
100 PRINT "특별한 숫자입니다!"
```

**비교 연산자:**
- `=` : 같음
- `<>` : 같지 않음
- `<` : 작음
- `>` : 큼
- `<=` : 작거나 같음
- `>=` : 크거나 같음

**논리 연산자:**
- `AND` : 그리고
- `OR` : 또는
- `NOT` : 아닌

#### FOR/NEXT 반복문

```basic
# 기본 반복
10 FOR I = 1 TO 10
20 PRINT "숫자: "; I
30 NEXT I

# STEP으로 증가값 지정
40 FOR I = 0 TO 100 STEP 5
50 PRINT I;
60 NEXT I

# 역순 반복
70 FOR I = 10 TO 1 STEP -1
80 PRINT I; " ";
90 NEXT I

# 중첩 반복
100 FOR I = 1 TO 5
110   FOR J = 1 TO 3
120     PRINT I; ","; J; " ";
130   NEXT J
140   PRINT
150 NEXT I
```

#### WHILE/WEND 반복문 (일부 구현체)

```basic
10 N = 1
20 WHILE N <= 10
30   PRINT N
40   N = N + 1
50 WEND
```

### 서브루틴

#### GOSUB/RETURN

```basic
10 GOSUB 1000          # 서브루틴 호출
20 PRINT "메인으로 돌아옴"
30 END

1000 REM 서브루틴 시작
1010 PRINT "서브루틴에서 실행 중"
1020 RETURN
```

#### ON/GOSUB 다중 분기

```basic
10 INPUT "선택 (1-3): "; CHOICE
20 ON CHOICE GOSUB 100, 200, 300
30 END

100 PRINT "첫 번째 선택"
110 RETURN

200 PRINT "두 번째 선택"  
210 RETURN

300 PRINT "세 번째 선택"
310 RETURN
```

## 🎮 내장 명령어

### 프로그램 관리

| 명령어 | 설명 | 예제 |
|--------|------|------|
| `NEW` | 프로그램 메모리 지움 | `NEW` |
| `LIST` | 프로그램 목록 출력 | `LIST`, `LIST 10-50` |
| `RUN` | 프로그램 실행 | `RUN`, `RUN 100` |
| `STOP` | 프로그램 중단 | `STOP` |
| `END` | 프로그램 종료 | `END` |
| `CONT` | 중단된 프로그램 계속 | `CONT` |

### 편집 명령

```basic
# 라인 삽입/수정
15 PRINT "새로운 라인"

# 라인 삭제
LIST 20        # 20번 라인 확인
20             # 20번 라인 삭제 (빈 라인 입력)

# 여러 라인 삭제  
NEW            # 전체 삭제
```

### 메모리 관리

```basic
# 변수 초기화
CLEAR

# 메모리 상태 확인
PRINT FRE(0)   # 사용 가능한 메모리 출력

# 특정 주소의 메모리 읽기/쓰기
PRINT PEEK(1024)    # 주소 1024 읽기
POKE 1024, 255      # 주소 1024에 255 쓰기
```

### 디버깅 명령

```basic
# 실행 추적
TRACE ON       # 추적 모드 켜기
TRACE OFF      # 추적 모드 끄기

# 에러 정보
PRINT ERR      # 에러 코드
PRINT ERL      # 에러 발생 라인
```

## 🧮 수학 함수

### 기본 산술 연산

```basic
10 PRINT 2 + 3         # 덧셈: 5
20 PRINT 7 - 4         # 뺄셈: 3  
30 PRINT 6 * 8         # 곱셈: 48
40 PRINT 15 / 3        # 나눗셈: 5
50 PRINT 17 MOD 5      # 나머지: 2
60 PRINT 2 ^ 3         # 거듭제곱: 8
```

### 수학 함수

#### 기본 함수

```basic
10 PRINT ABS(-5)       # 절댓값: 5
20 PRINT SGN(-3)       # 부호: -1 (음수), 0 (영), 1 (양수)
30 PRINT INT(3.7)      # 정수 부분: 3
40 PRINT SQR(16)       # 제곱근: 4
```

#### 삼각함수 (라디안)

```basic
10 PI = 3.14159265
20 PRINT SIN(PI/2)     # 사인: 1
30 PRINT COS(0)        # 코사인: 1
40 PRINT TAN(PI/4)     # 탄젠트: 1
50 PRINT ATN(1)        # 아크탄젠트: 0.785398 (π/4)

# 도를 라디안으로 변환
60 DEG = 90
70 RAD = DEG * PI / 180
80 PRINT SIN(RAD)      # 90도의 사인: 1
```

#### 로그와 지수

```basic
10 PRINT LOG(2.71828)  # 자연로그: 1
20 PRINT EXP(1)        # e의 거듭제곱: 2.71828
30 PRINT EXP(LOG(5))   # 5

# 상용로그 계산 (밑이 10)
40 PRINT LOG(100) / LOG(10)  # 2
```

#### 난수 생성

```basic
# 0-1 사이 난수
10 PRINT RND(1)

# 1-6 사이 주사위
20 DICE = INT(RND(1) * 6) + 1
30 PRINT "주사위: "; DICE

# 난수 시드 설정
40 RANDOMIZE TIMER     # 현재 시간으로 시드 설정
50 RANDOMIZE 12345     # 특정 값으로 시드 설정

# 범위 내 정수 난수 생성
60 MIN = 10: MAX = 50
70 N = INT(RND(1) * (MAX - MIN + 1)) + MIN
80 PRINT "10-50 사이 난수: "; N
```

## 📝 문자열 처리

### 문자열 기본 연산

```basic
# 문자열 연결
10 A$ = "HELLO"
20 B$ = "WORLD"
30 C$ = A$ + " " + B$  # "HELLO WORLD"

# 문자열 비교
40 IF A$ = "HELLO" THEN PRINT "일치"
50 IF A$ < B$ THEN PRINT "사전 순서상 A$가 앞"
```

### 문자열 함수

#### 부분 문자열

```basic
10 TEXT$ = "PROGRAMMING"

# 왼쪽에서 문자 추출
20 PRINT LEFT$(TEXT$, 4)    # "PROG"

# 오른쪽에서 문자 추출  
30 PRINT RIGHT$(TEXT$, 4)   # "MING"

# 중간에서 문자 추출
40 PRINT MID$(TEXT$, 3, 4)  # "OGRA"
50 PRINT MID$(TEXT$, 5)     # "RAMMING" (끝까지)
```

#### 문자열 정보

```basic
10 TEXT$ = "HELLO WORLD"
20 PRINT LEN(TEXT$)         # 길이: 11

# 특정 문자의 위치 찾기 (일부 구현체)
30 POS = INSTR(TEXT$, "WORLD")
40 IF POS > 0 THEN PRINT "WORLD는 "; POS; "번째 위치"
```

#### 문자열 변환

```basic
# 숫자를 문자열로
10 N = 123
20 S$ = STR$(N)        # " 123" (공백 포함)
30 S$ = RIGHT$(STR$(N), LEN(STR$(N)) - 1)  # "123" (공백 제거)

# 문자열을 숫자로
40 N = VAL("456")      # 456
50 N = VAL("12.34")    # 12.34
60 N = VAL("ABC")      # 0 (변환 불가능)

# ASCII 코드 변환
70 PRINT ASC("A")      # 65
80 PRINT CHR$(65)      # "A"
```

### 고급 문자열 처리

#### 문자열 검색과 치환

```basic
# 간단한 검색 함수
100 DEF FN FIND$(TEXT$, SEARCH$) = INSTR(TEXT$, SEARCH$)

# 대소문자 변환 (ASCII 이용)
110 DEF FN UPPER$(S$) = CHR$(ASC(S$) - 32)  # 소문자를 대문자로
120 DEF FN LOWER$(S$) = CHR$(ASC(S$) + 32)  # 대문자를 소문자로

# 문자열 역순
200 TEXT$ = "HELLO"
210 REVERSE$ = ""
220 FOR I = LEN(TEXT$) TO 1 STEP -1
230   REVERSE$ = REVERSE$ + MID$(TEXT$, I, 1)
240 NEXT I
250 PRINT REVERSE$  # "OLLEH"
```

#### 문자열 배열과 정렬

```basic
# 문자열 배열 정렬 (버블 정렬)
10 DIM NAMES$(4)
20 NAMES$(0) = "CHARLIE"
30 NAMES$(1) = "ALICE"  
40 NAMES$(2) = "BOB"
50 NAMES$(3) = "DAVID"

60 REM 버블 정렬
70 FOR I = 0 TO 3
80   FOR J = 0 TO 2
90     IF NAMES$(J) > NAMES$(J+1) THEN SWAP NAMES$(J), NAMES$(J+1)
100   NEXT J
110 NEXT I

120 FOR I = 0 TO 3
130   PRINT NAMES$(I)
140 NEXT I
```

## 💾 파일 관리

### 기본 파일 작업

```basic
# 프로그램 저장
SAVE "MYPROG"

# 프로그램 불러오기
LOAD "MYPROG"

# 저장된 파일 목록
DIR
# 또는
FILES

# 파일 삭제
KILL "OLDPROG"

# 프로그램 확인
VERIFY "MYPROG"
```

### 데이터 파일 처리

#### 데이터 저장하기

```basic
# 데이터를 프로그램에 포함
10 DATA "김철수", 25, "서울"
20 DATA "이영희", 30, "부산"  
30 DATA "박민수", 22, "대구"

# 데이터 읽기
40 FOR I = 1 TO 3
50   READ NAME$, AGE, CITY$
60   PRINT NAME$; AGE; CITY$
70 NEXT I

# 데이터 포인터 리셋
80 RESTORE
90 READ FIRST_NAME$
100 PRINT "첫 번째 이름: "; FIRST_NAME$
```

#### 파일 I/O (고급)

```basic
# 파일 열기 (일부 구현체에서만 지원)
10 OPEN "DATA.TXT" FOR OUTPUT AS #1

# 파일에 쓰기
20 FOR I = 1 TO 10
30   PRINT #1, I; I*I
40 NEXT I

# 파일 닫기
50 CLOSE #1

# 파일에서 읽기
60 OPEN "DATA.TXT" FOR INPUT AS #1
70 WHILE NOT EOF(1)
80   INPUT #1, NUM, SQUARE
90   PRINT NUM; "의 제곱: "; SQUARE
100 WEND
110 CLOSE #1
```

## 🔍 디버깅 도구

### 오류 처리

#### 일반적인 오류 유형

| 오류 코드 | 메시지 | 설명 |
|-----------|--------|------|
| 2 | `SYNTAX ERROR` | 문법 오류 |
| 6 | `OVERFLOW` | 수치 오버플로우 |
| 9 | `SUBSCRIPT OUT OF RANGE` | 배열 인덱스 범위 초과 |
| 11 | `DIVISION BY ZERO` | 0으로 나누기 |
| 13 | `TYPE MISMATCH` | 타입 불일치 |
| 14 | `OUT OF STRING SPACE` | 문자열 공간 부족 |

#### 에러 트래핑

```basic
# 에러 발생 시 특정 라인으로 이동
10 ON ERROR GOTO 1000

20 INPUT "숫자를 입력하세요: "; N
30 PRINT "결과: "; 100 / N
40 END

1000 REM 에러 처리
1010 PRINT "에러 발생! 코드: "; ERR
1020 PRINT "에러 라인: "; ERL
1030 RESUME NEXT   # 다음 라인부터 계속
```

### 실행 추적

```basic
# 추적 모드 활성화
TRON    # 또는 TRACE ON

# 프로그램 실행 (각 라인 번호가 표시됨)
10 FOR I = 1 TO 3
20   PRINT I
30 NEXT I

# 추적 모드 비활성화
TROFF   # 또는 TRACE OFF
```

### 변수 모니터링

```basic
# 변수 값 확인
10 A = 10
20 B = 20
30 C = A + B
40 PRINT "A="; A; "B="; B; "C="; C

# 배열 전체 출력
50 DIM NUMS(5)
60 FOR I = 0 TO 5
70   NUMS(I) = I * 10
80 NEXT I

90 FOR I = 0 TO 5  
100   PRINT "NUMS("; I; ")="; NUMS(I)
110 NEXT I
```

### 단계별 실행

대부분의 구현체에서 다음 키를 지원합니다:

- `Ctrl+C` : 프로그램 중단
- `Ctrl+S` : 출력 일시 중지/재개
- `ESC` : 현재 명령 취소

## 🎯 고급 기능

### 사용자 정의 함수

```basic
# 단일 라인 함수 정의
10 DEF FN SQUARE(X) = X * X
20 DEF FN AREA(R) = 3.14159 * R * R

# 함수 사용
30 PRINT FN SQUARE(5)      # 25
40 PRINT FN AREA(3)        # 28.27

# 복잡한 함수
50 DEF FN MAX(A, B) = (A + B + ABS(A - B)) / 2
60 PRINT FN MAX(10, 7)     # 10
```

### 배열과 다차원 데이터

#### 2차원 배열

```basic
# 2차원 배열 선언 (행렬)
10 DIM MATRIX(3, 3)

# 배열 초기화
20 FOR ROW = 0 TO 3
30   FOR COL = 0 TO 3
40     MATRIX(ROW, COL) = ROW * 10 + COL
50   NEXT COL
60 NEXT ROW

# 배열 출력
70 FOR ROW = 0 TO 3
80   FOR COL = 0 TO 3
90     PRINT MATRIX(ROW, COL);
100   NEXT COL
110   PRINT
120 NEXT ROW
```

#### 동적 배열 크기

```basic
# 배열 크기를 런타임에 결정
10 INPUT "배열 크기: "; SIZE
20 DIM NUMBERS(SIZE)

30 FOR I = 0 TO SIZE
40   NUMBERS(I) = RND(1) * 100
50 NEXT I

60 REM 배열 정렬
70 FOR I = 0 TO SIZE - 1
80   FOR J = I + 1 TO SIZE
90     IF NUMBERS(I) > NUMBERS(J) THEN SWAP NUMBERS(I), NUMBERS(J)
100   NEXT J
110 NEXT I
```

### 메모리 직접 제어

```basic
# 특정 메모리 주소 조작
10 ADDR = 2048             # 시작 주소
20 FOR I = 0 TO 255
30   POKE ADDR + I, I      # 연속된 값 저장
40 NEXT I

# 메모리 내용 확인
50 FOR I = 0 TO 15
60   PRINT PEEK(ADDR + I);
70 NEXT I

# 메모리 블록 복사
80 SRC = 2048
90 DEST = 3072
100 FOR I = 0 TO 255
110   POKE DEST + I, PEEK(SRC + I)
120 NEXT I
```

### 성능 최적화 팁

```basic
# 1. 변수를 미리 계산
10 PI = 3.14159265
20 TWO_PI = 2 * PI

# 2. 반복문에서 계산 최소화  
30 FOR I = 1 TO 1000
40   RESULT = SIN(I * PI / 180)    # 매번 계산
50 NEXT I

# 개선된 버전
60 STEP_SIZE = PI / 180
70 FOR I = 1 TO 1000
80   RESULT = SIN(I * STEP_SIZE)   # 계산 한 번만
90 NEXT I

# 3. 문자열 연산 최적화
100 TEXT$ = ""
110 FOR I = 1 TO 1000
120   TEXT$ = TEXT$ + STR$(I)      # 비효율적
130 NEXT I

# 개선된 버전 (가능한 경우)
140 DIM PARTS$(1000)
150 FOR I = 1 TO 1000
160   PARTS$(I) = STR$(I)
170 NEXT I
# 마지막에 한 번에 결합
```

## 💡 예제 프로그램

### 1. 간단한 계산기

```basic
100 REM === 간단한 계산기 ===
110 PRINT "간단한 계산기"
120 PRINT "==============="
130 PRINT

140 INPUT "첫 번째 숫자: "; A
150 INPUT "연산자 (+,-,*,/): "; OP$
160 INPUT "두 번째 숫자: "; B

170 IF OP$ = "+" THEN RESULT = A + B
180 IF OP$ = "-" THEN RESULT = A - B  
190 IF OP$ = "*" THEN RESULT = A * B
200 IF OP$ = "/" THEN RESULT = A / B

210 PRINT A; " "; OP$; " "; B; " = "; RESULT
220 PRINT
230 INPUT "계속하시겠습니까? (Y/N): "; CONT$
240 IF CONT$ = "Y" OR CONT$ = "y" THEN GOTO 140
250 PRINT "계산기를 종료합니다."
260 END
```

### 2. 구구단 출력

```basic
100 REM === 구구단 프로그램 ===
110 PRINT "구구단 출력 프로그램"
120 PRINT "=================="
130 PRINT

140 INPUT "몇 단을 출력할까요? (1-9): "; DAN
150 IF DAN < 1 OR DAN > 9 THEN GOTO 140

160 PRINT DAN; "단:"
170 PRINT "----"
180 FOR I = 1 TO 9
190   PRINT DAN; " x "; I; " = "; DAN * I
200 NEXT I

210 PRINT
220 INPUT "전체 구구단을 출력할까요? (Y/N): "; ALL$
230 IF ALL$ <> "Y" AND ALL$ <> "y" THEN END

240 PRINT
250 PRINT "전체 구구단:"
260 PRINT "==========="
270 FOR I = 1 TO 9
280   PRINT I; "단:"
290   FOR J = 1 TO 9
300     PRINT "  "; I; "x"; J; "="; I*J
310   NEXT J
320   PRINT
330 NEXT I
340 END
```

### 3. 숫자 맞추기 게임

```basic
100 REM === 숫자 맞추기 게임 ===
110 PRINT "숫자 맞추기 게임"
120 PRINT "================"
130 PRINT "1부터 100 사이의 숫자를 맞춰보세요!"
140 PRINT

150 RANDOMIZE TIMER
160 SECRET = INT(RND(1) * 100) + 1
170 TRIES = 0
180 MAX_TRIES = 7

190 REM 게임 루프
200 TRIES = TRIES + 1
210 PRINT "시도 횟수: "; TRIES; "/"; MAX_TRIES
220 INPUT "추측한 숫자: "; GUESS

230 IF GUESS = SECRET THEN GOTO 300
240 IF GUESS < SECRET THEN PRINT "더 큰 수입니다!"
250 IF GUESS > SECRET THEN PRINT "더 작은 수입니다!"

260 IF TRIES >= MAX_TRIES THEN GOTO 350
270 PRINT
280 GOTO 200

300 REM 성공
310 PRINT "정답입니다! 축하합니다!"
320 PRINT "정답: "; SECRET
330 PRINT TRIES; "번 만에 맞췄습니다."
340 GOTO 360

350 REM 실패  
360 PRINT "아쉽게도 실패했습니다."
370 PRINT "정답은 "; SECRET; "이었습니다."

380 PRINT
390 INPUT "다시 하시겠습니까? (Y/N): "; AGAIN$
400 IF AGAIN$ = "Y" OR AGAIN$ = "y" THEN GOTO 150
410 PRINT "게임을 종료합니다. 안녕히 가세요!"
420 END
```

### 4. 간단한 주소록

```basic
100 REM === 간단한 주소록 ===
110 DIM NAMES$(50)
120 DIM PHONES$(50)
130 COUNT = 0

140 REM 메인 메뉴
150 PRINT
160 PRINT "=== 주소록 ==="
170 PRINT "1. 연락처 추가"
180 PRINT "2. 연락처 검색"
190 PRINT "3. 전체 목록"
200 PRINT "4. 종료"
210 PRINT
220 INPUT "선택: "; CHOICE

230 ON CHOICE GOSUB 300, 400, 500, 600
240 GOTO 150

300 REM 연락처 추가
310 IF COUNT >= 50 THEN PRINT "주소록이 가득 찼습니다!": RETURN
320 INPUT "이름: "; NAME$
330 INPUT "전화번호: "; PHONE$
340 COUNT = COUNT + 1
350 NAMES$(COUNT) = NAME$
360 PHONES$(COUNT) = PHONE$
370 PRINT "연락처가 추가되었습니다."
380 RETURN

400 REM 연락처 검색
410 IF COUNT = 0 THEN PRINT "등록된 연락처가 없습니다.": RETURN
420 INPUT "검색할 이름: "; SEARCH$
430 FOR I = 1 TO COUNT
440   IF NAMES$(I) = SEARCH$ THEN PRINT "전화번호: "; PHONES$(I): RETURN
450 NEXT I
460 PRINT "연락처를 찾을 수 없습니다."
470 RETURN

500 REM 전체 목록
510 IF COUNT = 0 THEN PRINT "등록된 연락처가 없습니다.": RETURN
520 PRINT "=== 전체 연락처 ==="
530 FOR I = 1 TO COUNT
540   PRINT I; ". "; NAMES$(I); " - "; PHONES$(I)
550 NEXT I
560 RETURN

600 REM 종료
610 PRINT "주소록을 종료합니다."
620 END
```

### 5. 그래픽 패턴 그리기

```basic
100 REM === 별 패턴 그리기 ===
110 PRINT "별 패턴 그리기"
120 PRINT "=============="
130 PRINT

140 INPUT "패턴 높이 (1-20): "; HEIGHT
150 IF HEIGHT < 1 OR HEIGHT > 20 THEN GOTO 140

160 PRINT
170 PRINT "패턴 1: 삼각형"
180 FOR I = 1 TO HEIGHT
190   FOR J = 1 TO HEIGHT - I
200     PRINT " ";
210   NEXT J
220   FOR J = 1 TO 2 * I - 1
230     PRINT "*";
240   NEXT J
250   PRINT
260 NEXT I

270 PRINT
280 PRINT "패턴 2: 다이아몬드"
290 REM 위쪽 절반
300 FOR I = 1 TO HEIGHT
310   FOR J = 1 TO HEIGHT - I
320     PRINT " ";
330   NEXT J
340   FOR J = 1 TO 2 * I - 1
350     PRINT "*";
360   NEXT J
370   PRINT
380 NEXT I

390 REM 아래쪽 절반
400 FOR I = HEIGHT - 1 TO 1 STEP -1
410   FOR J = 1 TO HEIGHT - I
420     PRINT " ";
430   NEXT J
440   FOR J = 1 TO 2 * I - 1
450     PRINT "*";
460   NEXT J
470   PRINT
480 NEXT I

490 END
```

### 6. 간단한 텍스트 RPG

```basic
100 REM === 간단한 텍스트 RPG ===
110 PRINT "=== 용사의 모험 ==="
120 PRINT

130 REM 플레이어 초기화
140 PLAYER_HP = 100
150 PLAYER_ATK = 15
160 GOLD = 50

170 PRINT "용감한 모험가여, 환영합니다!"
180 PRINT "체력:"; PLAYER_HP; " 공격력:"; PLAYER_ATK; " 골드:"; GOLD
190 PRINT

200 REM 게임 루프
210 PRINT "=== 선택하세요 ==="
220 PRINT "1. 몬스터와 싸우기"
230 PRINT "2. 휴식하기"
240 PRINT "3. 상점 가기"
250 PRINT "4. 게임 종료"
260 INPUT "선택: "; ACTION

270 ON ACTION GOSUB 400, 600, 700, 800
280 IF PLAYER_HP <= 0 THEN GOTO 900
290 GOTO 200

400 REM 전투 시스템
410 MONSTER_HP = INT(RND(1) * 50) + 30
420 MONSTER_ATK = INT(RND(1) * 10) + 5
430 PRINT "야생의 오크가 나타났다!"
440 PRINT "오크 체력:"; MONSTER_HP; " 공격력:"; MONSTER_ATK

450 REM 전투 루프
460 IF MONSTER_HP <= 0 THEN GOTO 550
470 IF PLAYER_HP <= 0 THEN RETURN

480 PRINT
490 PRINT "1. 공격  2. 도망"
500 INPUT "행동: "; BATTLE_ACTION

510 IF BATTLE_ACTION = 2 THEN PRINT "도망쳤습니다!": RETURN

520 REM 플레이어 공격
530 DAMAGE = INT(RND(1) * PLAYER_ATK) + 5
540 MONSTER_HP = MONSTER_HP - DAMAGE
550 PRINT "오크에게"; DAMAGE; "의 데미지!"
560 IF MONSTER_HP <= 0 THEN GOTO 580

570 REM 몬스터 공격
580 DAMAGE = INT(RND(1) * MONSTER_ATK) + 2
590 PLAYER_HP = PLAYER_HP - DAMAGE
600 PRINT "오크의 공격! 당신이"; DAMAGE; "의 데미지를 입었습니다."
610 PRINT "현재 체력:"; PLAYER_HP
620 GOTO 460

630 REM 승리
640 REWARD = INT(RND(1) * 30) + 10
650 GOLD = GOLD + REWARD
660 PRINT "승리! 골드"; REWARD; "를 획득했습니다."
670 PRINT "현재 골드:"; GOLD
680 RETURN

690 REM 휴식
700 HEAL = 20
710 PLAYER_HP = PLAYER_HP + HEAL
720 IF PLAYER_HP > 100 THEN PLAYER_HP = 100
730 PRINT "휴식을 취했습니다. 체력"; HEAL; "회복!"
740 PRINT "현재 체력:"; PLAYER_HP
750 RETURN

760 REM 상점
770 PRINT "=== 상점 ==="
780 PRINT "1. 체력 물약 (30골드) - 체력 50 회복"
790 PRINT "2. 무기 강화 (100골드) - 공격력 +5"
800 PRINT "3. 나가기"
810 INPUT "구매: "; BUY

820 IF BUY = 1 AND GOLD >= 30 THEN GOLD = GOLD - 30: PLAYER_HP = PLAYER_HP + 50: IF PLAYER_HP > 100 THEN PLAYER_HP = 100: PRINT "체력 물약 구매!"
830 IF BUY = 2 AND GOLD >= 100 THEN GOLD = GOLD - 100: PLAYER_ATK = PLAYER_ATK + 5: PRINT "무기 강화 완료!"
840 IF BUY = 1 OR BUY = 2 THEN PRINT "현재 골드:"; GOLD
850 RETURN

860 REM 게임 종료
870 PRINT "모험을 마치고 마을로 돌아갑니다."
880 END

890 REM 게임 오버
900 PRINT
910 PRINT "=== GAME OVER ==="
920 PRINT "용사가 쓰러졌습니다..."
930 PRINT "최종 골드:"; GOLD
940 END
```

이 사용자 가이드를 통해 6502 BASIC JavaScript 에뮬레이터의 모든 기능을 효과적으로 활용할 수 있습니다. 더 많은 예제와 고급 기능은 프로젝트의 `examples/` 폴더를 참조하세요!