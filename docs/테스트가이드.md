# 테스트 가이드

> 6502 BASIC 에뮬레이터 테스트 실행 및 작성 가이드

[![Test Coverage](https://img.shields.io/badge/coverage-90%25-brightgreen.svg)](#test-coverage)
[![Tests](https://img.shields.io/badge/tests-1400%2B-success.svg)](#test-statistics)

## 📋 목차

1. [테스트 실행](#테스트-실행)
2. [테스트 작성 패턴](#테스트-작성-패턴)
3. [모킹 전략](#모킹-전략)
4. [테스트 통계](#테스트-통계)
5. [CI/CD 통합](#cicd-통합)
6. [트러블슈팅](#트러블슈팅)

## 🚀 테스트 실행

### 전체 테스트

```bash
# 모든 테스트 실행
bun test

# 테스트 통계 출력
bun test --verbose
```

### 모듈별 테스트

```bash
# 오디오 엔진 테스트 (97개 테스트)
bun test tests/audio/

# 그래픽 엔진 테스트 (161개 테스트)
bun test tests/graphics/

# 모바일 최적화 테스트 (228개 테스트)
bun test tests/mobile/

# 에디터 테스트 (189개 테스트)
bun test tests/editor/

# 디버거 테스트
bun test tests/debugger/
```

### 특정 테스트 파일 실행

```bash
# 오디오 엔진 단위 테스트
bun test tests/audio/audio-engine.test.ts

# 가상 키보드 테스트
bun test tests/mobile/virtual-keyboard.test.ts

# 문법 하이라이터 테스트
bun test tests/editor/syntax-highlighter.test.ts
```

### 통합 테스트

```bash
# 시스템 통합 테스트 (116개)
bun test tests/system-integration.test.ts

# E2E 사용자 시나리오
bun test tests/e2e/

# 성능 통합 테스트
bun test tests/performance-integration.test.ts
```

### 테스트 커버리지

```bash
# 커버리지 리포트 생성
bun test --coverage

# HTML 리포트 생성
bun test --coverage --coverage-reporter html

# 특정 디렉토리 커버리지
bun test tests/audio/ --coverage
```

### 지속 테스트 (Watch Mode)

```bash
# 파일 변경 감지하여 자동 재실행
bun test --watch

# 특정 디렉토리 감시
bun test tests/audio/ --watch
```

## ✍️ 테스트 작성 패턴

### 단위 테스트 예제

#### 오디오 엔진 테스트

```typescript
import { describe, test, expect, beforeEach, afterEach } from 'bun:test';
import { AudioEngine } from '@/audio/AudioEngine';

describe('AudioEngine', () => {
  let audio: AudioEngine;

  beforeEach(() => {
    audio = new AudioEngine({
      sampleRate: 44100,
      channels: 3,
      masterVolume: 0.8
    });
  });

  afterEach(() => {
    audio.dispose();
  });

  describe('MML Parsing', () => {
    test('should parse simple notes', () => {
      const tokens = audio.parseMML('CDEFGAB');
      expect(tokens).toHaveLength(7);
      expect(tokens[0]).toEqual({
        type: 'note',
        value: 'C',
        octave: 4,
        duration: 4
      });
    });

    test('should parse volume commands (V0-V15)', () => {
      const tokens = audio.parseMML('V15 C V0 D');
      expect(tokens[0]).toEqual({ type: 'volume', value: 15 });
      expect(tokens[2]).toEqual({ type: 'volume', value: 0 });
    });

    test('should parse waveform commands (W0-W3)', () => {
      const tokens = audio.parseMML('W0 C W1 D');
      expect(tokens[0]).toEqual({ type: 'waveform', value: 0 }); // sine
      expect(tokens[2]).toEqual({ type: 'waveform', value: 1 }); // square
    });

    test('should parse repeat patterns [...]n', () => {
      const tokens = audio.parseMML('[CDEFG]4');
      const repeatedNotes = audio.expandRepeats(tokens);
      expect(repeatedNotes).toHaveLength(20); // 5 notes × 4 repeats
    });

    test('should parse tied notes with &', () => {
      const tokens = audio.parseMML('C4&C4');
      expect(tokens).toHaveLength(1);
      expect(tokens[0].duration).toBe(2); // Two quarter notes = half note
    });
  });

  describe('Multi-Channel Playback', () => {
    test('should play on specific channel', async () => {
      let notesPlayed = 0;
      audio.on('noteStart', () => notesPlayed++);

      await audio.playMMLOnChannel(0, 'CDE');
      expect(notesPlayed).toBe(3);
    });

    test('should stop specific channel', async () => {
      audio.playMMLOnChannel(0, 'CDEFGAB'); // Don't await
      audio.stopChannel(0);

      const status = audio.getChannelStatus(0);
      expect(status.isPlaying).toBe(false);
    });

    test('should play on multiple channels simultaneously', async () => {
      const promises = [
        audio.playMMLOnChannel(0, 'CEG'), // Channel 0
        audio.playMMLOnChannel(1, 'CCC'), // Channel 1
        audio.playMMLOnChannel(2, 'EEE')  // Channel 2
      ];

      await Promise.all(promises);

      // All channels should have finished
      expect(audio.getChannelStatus(0).isPlaying).toBe(false);
      expect(audio.getChannelStatus(1).isPlaying).toBe(false);
      expect(audio.getChannelStatus(2).isPlaying).toBe(false);
    });
  });

  describe('Audio Effects', () => {
    test('should apply fade in', () => {
      audio.setMasterVolume(0);
      audio.fadeIn(1000);

      // After 500ms, volume should be around 0.4 (50% of 0.8)
      setTimeout(() => {
        expect(audio.getMasterVolume()).toBeCloseTo(0.4, 1);
      }, 500);
    });

    test('should apply ADSR envelope', () => {
      audio.setADSR(0.1, 0.2, 0.7, 0.5);
      const envelope = audio.getEnvelope();

      expect(envelope.attack).toBe(0.1);
      expect(envelope.decay).toBe(0.2);
      expect(envelope.sustain).toBe(0.7);
      expect(envelope.release).toBe(0.5);
    });
  });
});
```

#### 가상 키보드 테스트

```typescript
import { describe, test, expect, beforeEach } from 'bun:test';
import { VirtualKeyboard } from '@/mobile/VirtualKeyboard';

describe('VirtualKeyboard', () => {
  let keyboard: VirtualKeyboard;

  beforeEach(() => {
    keyboard = new VirtualKeyboard({
      layout: 'basic',
      hapticFeedback: true
    });
  });

  describe('Visibility Control', () => {
    test('should show and hide keyboard', () => {
      expect(keyboard.isVisible()).toBe(false);

      keyboard.show();
      expect(keyboard.isVisible()).toBe(true);

      keyboard.hide();
      expect(keyboard.isVisible()).toBe(false);
    });

    test('should toggle visibility', () => {
      keyboard.toggle();
      expect(keyboard.isVisible()).toBe(true);

      keyboard.toggle();
      expect(keyboard.isVisible()).toBe(false);
    });
  });

  describe('Layout Management', () => {
    test('should switch layouts', () => {
      keyboard.setLayout('numeric');
      expect(keyboard.getLayout()).toBe('numeric');

      keyboard.setLayout('symbols');
      expect(keyboard.getLayout()).toBe('symbols');
    });

    test('should emit layoutChange event', () => {
      let changedLayout: string | undefined;
      keyboard.on('layoutChange', (layout) => {
        changedLayout = layout;
      });

      keyboard.setLayout('numeric');
      expect(changedLayout).toBe('numeric');
    });
  });

  describe('Custom Keys', () => {
    test('should add custom key', () => {
      keyboard.addCustomKey({
        key: 'PRINT',
        label: 'PRINT',
        width: 2
      });

      const keys = keyboard.getKeys();
      expect(keys.some(k => k.key === 'PRINT')).toBe(true);
    });

    test('should remove custom key', () => {
      keyboard.addCustomKey({ key: 'TEST', label: 'TEST' });
      keyboard.removeCustomKey('TEST');

      const keys = keyboard.getKeys();
      expect(keys.some(k => k.key === 'TEST')).toBe(false);
    });
  });

  describe('Key Press Events', () => {
    test('should emit keyPress event', () => {
      let pressedKey: string | undefined;
      keyboard.onKeyPress((key) => {
        pressedKey = key;
      });

      keyboard.pressKey('A');
      expect(pressedKey).toBe('A');
    });
  });
});
```

### 통합 테스트 예제

```typescript
import { describe, test, expect } from 'bun:test';
import { BasicEmulator } from '@/system/BasicEmulator';

describe('System Integration Tests', () => {
  describe('Audio-BASIC Integration', () => {
    test('should play audio from BASIC code', async () => {
      const emulator = new BasicEmulator();
      await emulator.initialize();

      const program = [
        '10 PLAY "T120 O4 CDEFGAB"',
        '20 END'
      ];

      await emulator.loadProgram(program);
      const result = await emulator.run();

      expect(result.success).toBe(true);
    });

    test('should play multi-channel audio', async () => {
      const emulator = new BasicEmulator();
      await emulator.initialize();

      const program = [
        '10 PLAYCH 0, "CEG"',  // Melody
        '20 PLAYCH 1, "CCC"',  // Bass
        '30 PLAYCH 2, "EEE"',  // Harmony
        '40 END'
      ];

      await emulator.loadProgram(program);
      const result = await emulator.run();

      expect(result.success).toBe(true);
    });
  });

  describe('Mobile-Graphics Integration', () => {
    test('should render graphics on mobile viewport', () => {
      const emulator = new BasicEmulator({
        viewport: 'mobile'
      });

      // Set screen mode
      emulator.executeCommand('SCREEN 1');

      // Draw on smaller viewport
      emulator.executeCommand('PSET (100, 100), 15');

      const pixel = emulator.getGraphics().getPixel(100, 100);
      expect(pixel).toBe(15);
    });

    test('should handle touch gestures on graphics', () => {
      const emulator = new BasicEmulator();
      const gestures = emulator.getGestureHandler();

      let tapped = false;
      gestures.on('tap', () => { tapped = true; });

      gestures.simulateTap(100, 100);
      expect(tapped).toBe(true);
    });
  });
});
```

### E2E 테스트 예제

```typescript
import { describe, test, expect } from 'bun:test';
import { BasicEmulator } from '@/system/BasicEmulator';

describe('E2E User Scenarios', () => {
  test('Complete game development workflow', async () => {
    const emulator = new BasicEmulator();
    await emulator.initialize();

    // 1. Create a simple number guessing game
    const game = [
      '10 CLS',
      '20 N = INT(RND(1) * 100) + 1',
      '30 PRINT "GUESS A NUMBER (1-100)"',
      '40 INPUT G',
      '50 IF G = N THEN PRINT "CORRECT!" : END',
      '60 IF G < N THEN PRINT "TOO LOW!"',
      '70 IF G > N THEN PRINT "TOO HIGH!"',
      '80 GOTO 40'
    ];

    // 2. Load program
    await emulator.loadProgram(game);
    expect(emulator.getProgramLines()).toHaveLength(8);

    // 3. Save to storage
    await emulator.save('GAME.BAS');
    expect(await emulator.fileExists('GAME.BAS')).toBe(true);

    // 4. Clear and reload
    emulator.executeCommand('NEW');
    expect(emulator.getProgramLines()).toHaveLength(0);

    await emulator.load('GAME.BAS');
    expect(emulator.getProgramLines()).toHaveLength(8);

    // 5. Run program (will wait for input)
    const runPromise = emulator.run();

    // 6. Simulate user input
    setTimeout(() => {
      emulator.provideInput('50');
    }, 100);

    const result = await runPromise;
    expect(result.success).toBe(true);
    expect(result.output).toContain('GUESS A NUMBER');
  });

  test('Audio composition workflow', async () => {
    const emulator = new BasicEmulator();
    await emulator.initialize();

    const composition = [
      '10 REM SIMPLE MELODY COMPOSER',
      '20 PLAY "T120 O4"',
      '30 PLAY "[CDEFG]2"',        // Repeat scale
      '40 PLAYCH 1, "T120 O2 CCC"', // Bass line
      '50 PLAY "V10 MS CDEFG"',    // Staccato ending
      '60 END'
    ];

    await emulator.loadProgram(composition);
    const result = await emulator.run();

    expect(result.success).toBe(true);

    // Verify audio channels were used
    const audioEngine = emulator.getAudioEngine();
    const stats = audioEngine.getStats();
    expect(stats.channelsUsed).toBeGreaterThan(0);
  });

  test('Mobile responsive UI workflow', async () => {
    const emulator = new BasicEmulator({
      viewport: 'mobile'
    });
    await emulator.initialize();

    // 1. Show virtual keyboard
    const keyboard = emulator.getVirtualKeyboard();
    keyboard.show();
    expect(keyboard.isVisible()).toBe(true);

    // 2. Switch to BASIC layout
    keyboard.setLayout('basic');
    expect(keyboard.getLayout()).toBe('basic');

    // 3. Type BASIC command
    keyboard.type('PRINT "HELLO"');

    // 4. Execute
    const result = await emulator.executeCommand('PRINT "HELLO"');
    expect(result.output).toBe('HELLO\n');

    // 5. Monitor performance
    const perfMonitor = emulator.getPerformanceMonitor();
    const metrics = perfMonitor.getMetrics();
    expect(metrics.fps).toBeGreaterThan(30);
  });
});
```

## 🎭 모킹 전략

### Web Audio API 모킹

```typescript
import { beforeEach, afterEach } from 'bun:test';

// Mock AudioContext
class MockAudioContext {
  currentTime = 0;
  sampleRate = 44100;
  destination = {};

  createOscillator() {
    return new MockOscillator();
  }

  createGain() {
    return new MockGainNode();
  }

  createAnalyser() {
    return new MockAnalyser();
  }
}

class MockOscillator {
  frequency = { value: 440 };
  type = 'sine';

  connect() {}
  start() {}
  stop() {}
}

class MockGainNode {
  gain = { value: 1 };

  connect() {}
}

// Setup in tests
beforeEach(() => {
  global.AudioContext = MockAudioContext as any;
  global.webkitAudioContext = MockAudioContext as any;
});
```

### Canvas API 모킹

```typescript
class MockCanvasContext {
  fillStyle = '#000000';
  strokeStyle = '#000000';
  lineWidth = 1;

  fillRect(x: number, y: number, w: number, h: number) {
    // Record drawing operation
  }

  strokeRect(x: number, y: number, w: number, h: number) {
    // Record drawing operation
  }

  beginPath() {}
  closePath() {}
  moveTo(x: number, y: number) {}
  lineTo(x: number, y: number) {}
  arc(x: number, y: number, r: number, start: number, end: number) {}
  fill() {}
  stroke() {}
}

beforeEach(() => {
  global.HTMLCanvasElement.prototype.getContext = function(type: string) {
    return new MockCanvasContext();
  };
});
```

### Touch Events 모킹

```typescript
class MockTouchEvent extends Event {
  touches: Touch[];
  changedTouches: Touch[];

  constructor(type: string, init: any) {
    super(type, init);
    this.touches = init.touches || [];
    this.changedTouches = init.changedTouches || [];
  }
}

class MockTouch {
  constructor(
    public identifier: number,
    public clientX: number,
    public clientY: number
  ) {}
}

// Create touch events
function createTouchEvent(type: string, x: number, y: number) {
  const touch = new MockTouch(0, x, y);
  return new MockTouchEvent(type, {
    touches: [touch],
    changedTouches: [touch]
  });
}
```

### localStorage 모킹

```typescript
class MockLocalStorage {
  private store: Record<string, string> = {};

  getItem(key: string): string | null {
    return this.store[key] || null;
  }

  setItem(key: string, value: string): void {
    this.store[key] = value;
  }

  removeItem(key: string): void {
    delete this.store[key];
  }

  clear(): void {
    this.store = {};
  }

  get length(): number {
    return Object.keys(this.store).length;
  }

  key(index: number): string | null {
    const keys = Object.keys(this.store);
    return keys[index] || null;
  }
}

beforeEach(() => {
  global.localStorage = new MockLocalStorage() as any;
});
```

## 📊 테스트 통계

### 전체 테스트 현황

```
총 테스트 수: 1,400+ 개
통과율: 95%+
커버리지: 90%+
```

### 모듈별 테스트 수

| 모듈 | 테스트 수 | 통과율 | 커버리지 |
|------|----------|--------|----------|
| 오디오 엔진 | 97 | 100% | 95% |
| 그래픽 엔진 | 161 | 100% | 100% |
| 모바일 최적화 | 228 | 95% | 92% |
| 에디터 | 189 | 100% | 98% |
| 디버거 | 58 | 100% | 90% |
| 시스템 통합 | 116 | 98% | 88% |
| E2E 시나리오 | 45 | 93% | N/A |
| CPU 에뮬레이터 | 150+ | 98% | 95% |
| BASIC 인터프리터 | 200+ | 96% | 92% |
| 메모리 관리 | 80+ | 100% | 97% |

### 테스트 카테고리

```typescript
// 단위 테스트 (Unit Tests)
- 개별 함수/클래스 테스트
- 1,000+ 테스트
- 실행 시간: < 5초

// 통합 테스트 (Integration Tests)
- 모듈 간 상호작용 테스트
- 300+ 테스트
- 실행 시간: < 30초

// E2E 테스트 (End-to-End Tests)
- 사용자 시나리오 테스트
- 100+ 테스트
- 실행 시간: < 2분

// 성능 테스트 (Performance Tests)
- 벤치마크 및 프로파일링
- 50+ 테스트
- 실행 시간: < 1분
```

## 🔄 CI/CD 통합

### GitHub Actions 설정

```yaml
# .github/workflows/test.yml
name: Tests

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3

    - name: Setup Bun
      uses: oven-sh/setup-bun@v1
      with:
        bun-version: latest

    - name: Install dependencies
      run: bun install

    - name: Run tests
      run: bun test

    - name: Generate coverage report
      run: bun test --coverage

    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        files: ./coverage/coverage-final.json
        fail_ci_if_error: true
```

### Pre-commit Hooks

```bash
# .husky/pre-commit
#!/bin/sh
. "$(dirname "$0")/_/husky.sh"

# Run tests before commit
bun test

# Run linter
bun run lint

# Check TypeScript types
bun run typecheck
```

## 🐛 트러블슈팅

### 일반적인 문제

#### 1. 테스트 타임아웃

```typescript
// 문제: 비동기 테스트 타임아웃
test('async test', async () => {
  await longRunningOperation();
});

// 해결: 타임아웃 증가
test('async test', async () => {
  await longRunningOperation();
}, { timeout: 10000 }); // 10초
```

#### 2. 모킹 실패

```typescript
// 문제: AudioContext 모킹 안됨
test('audio test', () => {
  const audio = new AudioEngine(); // Error: AudioContext is not defined
});

// 해결: beforeEach에서 모킹
beforeEach(() => {
  global.AudioContext = MockAudioContext as any;
});
```

#### 3. 메모리 누수

```typescript
// 문제: 테스트 후 리소스 정리 안됨
test('resource test', () => {
  const resource = new Resource();
  // 테스트 코드...
}); // Resource not cleaned up

// 해결: afterEach 사용
let resource: Resource;

beforeEach(() => {
  resource = new Resource();
});

afterEach(() => {
  resource.dispose();
});
```

#### 4. 경쟁 조건 (Race Conditions)

```typescript
// 문제: 비동기 작업 순서 보장 안됨
test('concurrent test', async () => {
  operation1(); // Don't await
  operation2(); // Race condition!
});

// 해결: Promise.all 사용
test('concurrent test', async () => {
  await Promise.all([
    operation1(),
    operation2()
  ]);
});
```

### 디버깅 팁

```bash
# 1. 특정 테스트만 실행 (debugging)
bun test --test-name-pattern "should parse MML"

# 2. 상세 출력
bun test --verbose

# 3. 실패한 테스트만 재실행
bun test --only-failures

# 4. 테스트 디버거 사용
bun test --inspect-brk tests/audio/audio-engine.test.ts
```

### 성능 최적화

```typescript
// 느린 테스트 최적화
describe('Performance Tests', () => {
  // Bad: 매 테스트마다 생성
  test('test 1', () => {
    const emulator = new BasicEmulator(); // Slow
  });

  test('test 2', () => {
    const emulator = new BasicEmulator(); // Slow
  });

  // Good: 한 번만 생성
  let emulator: BasicEmulator;

  beforeAll(() => {
    emulator = new BasicEmulator();
  });

  afterAll(() => {
    emulator.dispose();
  });

  test('test 1', () => {
    emulator.reset();
    // 테스트...
  });

  test('test 2', () => {
    emulator.reset();
    // 테스트...
  });
});
```

## 📚 추가 자료

### 테스트 관련 문서
- [Bun Test Runner](https://bun.sh/docs/cli/test)
- [Testing Best Practices](https://github.com/goldbergyoni/javascript-testing-best-practices)
- [Test-Driven Development](https://martinfowler.com/bliki/TestDrivenDevelopment.html)

### 관련 가이드
- [개발자 가이드](./개발자가이드.md)
- [API 문서](./API문서.md)
- [기여 가이드](./기여가이드.md)

---

**버전**: 2.0.0
**마지막 업데이트**: 2025-10-04
**테스트 프레임워크**: Bun Test Runner 1.0+

