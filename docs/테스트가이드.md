# í…ŒìŠ¤íŠ¸ ê°€ì´ë“œ

> 6502 BASIC ì—ë®¬ë ˆì´í„° í…ŒìŠ¤íŠ¸ ì‹¤í–‰ ë° ì‘ì„± ê°€ì´ë“œ

[![Test Coverage](https://img.shields.io/badge/coverage-90%25-brightgreen.svg)](#test-coverage)
[![Tests](https://img.shields.io/badge/tests-1400%2B-success.svg)](#test-statistics)

## ğŸ“‹ ëª©ì°¨

1. [í…ŒìŠ¤íŠ¸ ì‹¤í–‰](#í…ŒìŠ¤íŠ¸-ì‹¤í–‰)
2. [í…ŒìŠ¤íŠ¸ ì‘ì„± íŒ¨í„´](#í…ŒìŠ¤íŠ¸-ì‘ì„±-íŒ¨í„´)
3. [ëª¨í‚¹ ì „ëµ](#ëª¨í‚¹-ì „ëµ)
4. [í…ŒìŠ¤íŠ¸ í†µê³„](#í…ŒìŠ¤íŠ¸-í†µê³„)
5. [CI/CD í†µí•©](#cicd-í†µí•©)
6. [íŠ¸ëŸ¬ë¸”ìŠˆíŒ…](#íŠ¸ëŸ¬ë¸”ìŠˆíŒ…)

## ğŸš€ í…ŒìŠ¤íŠ¸ ì‹¤í–‰

### ì „ì²´ í…ŒìŠ¤íŠ¸

```bash
# ëª¨ë“  í…ŒìŠ¤íŠ¸ ì‹¤í–‰
bun test

# í…ŒìŠ¤íŠ¸ í†µê³„ ì¶œë ¥
bun test --verbose
```

### ëª¨ë“ˆë³„ í…ŒìŠ¤íŠ¸

```bash
# ì˜¤ë””ì˜¤ ì—”ì§„ í…ŒìŠ¤íŠ¸ (97ê°œ í…ŒìŠ¤íŠ¸)
bun test tests/audio/

# ê·¸ë˜í”½ ì—”ì§„ í…ŒìŠ¤íŠ¸ (161ê°œ í…ŒìŠ¤íŠ¸)
bun test tests/graphics/

# ëª¨ë°”ì¼ ìµœì í™” í…ŒìŠ¤íŠ¸ (228ê°œ í…ŒìŠ¤íŠ¸)
bun test tests/mobile/

# ì—ë””í„° í…ŒìŠ¤íŠ¸ (189ê°œ í…ŒìŠ¤íŠ¸)
bun test tests/editor/

# ë””ë²„ê±° í…ŒìŠ¤íŠ¸
bun test tests/debugger/
```

### íŠ¹ì • í…ŒìŠ¤íŠ¸ íŒŒì¼ ì‹¤í–‰

```bash
# ì˜¤ë””ì˜¤ ì—”ì§„ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸
bun test tests/audio/audio-engine.test.ts

# ê°€ìƒ í‚¤ë³´ë“œ í…ŒìŠ¤íŠ¸
bun test tests/mobile/virtual-keyboard.test.ts

# ë¬¸ë²• í•˜ì´ë¼ì´í„° í…ŒìŠ¤íŠ¸
bun test tests/editor/syntax-highlighter.test.ts
```

### í†µí•© í…ŒìŠ¤íŠ¸

```bash
# ì‹œìŠ¤í…œ í†µí•© í…ŒìŠ¤íŠ¸ (116ê°œ)
bun test tests/system-integration.test.ts

# E2E ì‚¬ìš©ì ì‹œë‚˜ë¦¬ì˜¤
bun test tests/e2e/

# ì„±ëŠ¥ í†µí•© í…ŒìŠ¤íŠ¸
bun test tests/performance-integration.test.ts
```

### í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€

```bash
# ì»¤ë²„ë¦¬ì§€ ë¦¬í¬íŠ¸ ìƒì„±
bun test --coverage

# HTML ë¦¬í¬íŠ¸ ìƒì„±
bun test --coverage --coverage-reporter html

# íŠ¹ì • ë””ë ‰í† ë¦¬ ì»¤ë²„ë¦¬ì§€
bun test tests/audio/ --coverage
```

### ì§€ì† í…ŒìŠ¤íŠ¸ (Watch Mode)

```bash
# íŒŒì¼ ë³€ê²½ ê°ì§€í•˜ì—¬ ìë™ ì¬ì‹¤í–‰
bun test --watch

# íŠ¹ì • ë””ë ‰í† ë¦¬ ê°ì‹œ
bun test tests/audio/ --watch
```

## âœï¸ í…ŒìŠ¤íŠ¸ ì‘ì„± íŒ¨í„´

### ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ì˜ˆì œ

#### ì˜¤ë””ì˜¤ ì—”ì§„ í…ŒìŠ¤íŠ¸

```typescript
import { describe, test, expect, beforeEach, afterEach } from 'bun:test';
import { AudioEngine } from '@/audio/AudioEngine';

describe('AudioEngine', () => {
  let audio: AudioEngine;

  beforeEach(() => {
    audio = new AudioEngine({
      sampleRate: 44100,
      channels: 3,
      masterVolume: 0.8
    });
  });

  afterEach(() => {
    audio.dispose();
  });

  describe('MML Parsing', () => {
    test('should parse simple notes', () => {
      const tokens = audio.parseMML('CDEFGAB');
      expect(tokens).toHaveLength(7);
      expect(tokens[0]).toEqual({
        type: 'note',
        value: 'C',
        octave: 4,
        duration: 4
      });
    });

    test('should parse volume commands (V0-V15)', () => {
      const tokens = audio.parseMML('V15 C V0 D');
      expect(tokens[0]).toEqual({ type: 'volume', value: 15 });
      expect(tokens[2]).toEqual({ type: 'volume', value: 0 });
    });

    test('should parse waveform commands (W0-W3)', () => {
      const tokens = audio.parseMML('W0 C W1 D');
      expect(tokens[0]).toEqual({ type: 'waveform', value: 0 }); // sine
      expect(tokens[2]).toEqual({ type: 'waveform', value: 1 }); // square
    });

    test('should parse repeat patterns [...]n', () => {
      const tokens = audio.parseMML('[CDEFG]4');
      const repeatedNotes = audio.expandRepeats(tokens);
      expect(repeatedNotes).toHaveLength(20); // 5 notes Ã— 4 repeats
    });

    test('should parse tied notes with &', () => {
      const tokens = audio.parseMML('C4&C4');
      expect(tokens).toHaveLength(1);
      expect(tokens[0].duration).toBe(2); // Two quarter notes = half note
    });
  });

  describe('Multi-Channel Playback', () => {
    test('should play on specific channel', async () => {
      let notesPlayed = 0;
      audio.on('noteStart', () => notesPlayed++);

      await audio.playMMLOnChannel(0, 'CDE');
      expect(notesPlayed).toBe(3);
    });

    test('should stop specific channel', async () => {
      audio.playMMLOnChannel(0, 'CDEFGAB'); // Don't await
      audio.stopChannel(0);

      const status = audio.getChannelStatus(0);
      expect(status.isPlaying).toBe(false);
    });

    test('should play on multiple channels simultaneously', async () => {
      const promises = [
        audio.playMMLOnChannel(0, 'CEG'), // Channel 0
        audio.playMMLOnChannel(1, 'CCC'), // Channel 1
        audio.playMMLOnChannel(2, 'EEE')  // Channel 2
      ];

      await Promise.all(promises);

      // All channels should have finished
      expect(audio.getChannelStatus(0).isPlaying).toBe(false);
      expect(audio.getChannelStatus(1).isPlaying).toBe(false);
      expect(audio.getChannelStatus(2).isPlaying).toBe(false);
    });
  });

  describe('Audio Effects', () => {
    test('should apply fade in', () => {
      audio.setMasterVolume(0);
      audio.fadeIn(1000);

      // After 500ms, volume should be around 0.4 (50% of 0.8)
      setTimeout(() => {
        expect(audio.getMasterVolume()).toBeCloseTo(0.4, 1);
      }, 500);
    });

    test('should apply ADSR envelope', () => {
      audio.setADSR(0.1, 0.2, 0.7, 0.5);
      const envelope = audio.getEnvelope();

      expect(envelope.attack).toBe(0.1);
      expect(envelope.decay).toBe(0.2);
      expect(envelope.sustain).toBe(0.7);
      expect(envelope.release).toBe(0.5);
    });
  });
});
```

#### ê°€ìƒ í‚¤ë³´ë“œ í…ŒìŠ¤íŠ¸

```typescript
import { describe, test, expect, beforeEach } from 'bun:test';
import { VirtualKeyboard } from '@/mobile/VirtualKeyboard';

describe('VirtualKeyboard', () => {
  let keyboard: VirtualKeyboard;

  beforeEach(() => {
    keyboard = new VirtualKeyboard({
      layout: 'basic',
      hapticFeedback: true
    });
  });

  describe('Visibility Control', () => {
    test('should show and hide keyboard', () => {
      expect(keyboard.isVisible()).toBe(false);

      keyboard.show();
      expect(keyboard.isVisible()).toBe(true);

      keyboard.hide();
      expect(keyboard.isVisible()).toBe(false);
    });

    test('should toggle visibility', () => {
      keyboard.toggle();
      expect(keyboard.isVisible()).toBe(true);

      keyboard.toggle();
      expect(keyboard.isVisible()).toBe(false);
    });
  });

  describe('Layout Management', () => {
    test('should switch layouts', () => {
      keyboard.setLayout('numeric');
      expect(keyboard.getLayout()).toBe('numeric');

      keyboard.setLayout('symbols');
      expect(keyboard.getLayout()).toBe('symbols');
    });

    test('should emit layoutChange event', () => {
      let changedLayout: string | undefined;
      keyboard.on('layoutChange', (layout) => {
        changedLayout = layout;
      });

      keyboard.setLayout('numeric');
      expect(changedLayout).toBe('numeric');
    });
  });

  describe('Custom Keys', () => {
    test('should add custom key', () => {
      keyboard.addCustomKey({
        key: 'PRINT',
        label: 'PRINT',
        width: 2
      });

      const keys = keyboard.getKeys();
      expect(keys.some(k => k.key === 'PRINT')).toBe(true);
    });

    test('should remove custom key', () => {
      keyboard.addCustomKey({ key: 'TEST', label: 'TEST' });
      keyboard.removeCustomKey('TEST');

      const keys = keyboard.getKeys();
      expect(keys.some(k => k.key === 'TEST')).toBe(false);
    });
  });

  describe('Key Press Events', () => {
    test('should emit keyPress event', () => {
      let pressedKey: string | undefined;
      keyboard.onKeyPress((key) => {
        pressedKey = key;
      });

      keyboard.pressKey('A');
      expect(pressedKey).toBe('A');
    });
  });
});
```

### í†µí•© í…ŒìŠ¤íŠ¸ ì˜ˆì œ

```typescript
import { describe, test, expect } from 'bun:test';
import { BasicEmulator } from '@/system/BasicEmulator';

describe('System Integration Tests', () => {
  describe('Audio-BASIC Integration', () => {
    test('should play audio from BASIC code', async () => {
      const emulator = new BasicEmulator();
      await emulator.initialize();

      const program = [
        '10 PLAY "T120 O4 CDEFGAB"',
        '20 END'
      ];

      await emulator.loadProgram(program);
      const result = await emulator.run();

      expect(result.success).toBe(true);
    });

    test('should play multi-channel audio', async () => {
      const emulator = new BasicEmulator();
      await emulator.initialize();

      const program = [
        '10 PLAYCH 0, "CEG"',  // Melody
        '20 PLAYCH 1, "CCC"',  // Bass
        '30 PLAYCH 2, "EEE"',  // Harmony
        '40 END'
      ];

      await emulator.loadProgram(program);
      const result = await emulator.run();

      expect(result.success).toBe(true);
    });
  });

  describe('Mobile-Graphics Integration', () => {
    test('should render graphics on mobile viewport', () => {
      const emulator = new BasicEmulator({
        viewport: 'mobile'
      });

      // Set screen mode
      emulator.executeCommand('SCREEN 1');

      // Draw on smaller viewport
      emulator.executeCommand('PSET (100, 100), 15');

      const pixel = emulator.getGraphics().getPixel(100, 100);
      expect(pixel).toBe(15);
    });

    test('should handle touch gestures on graphics', () => {
      const emulator = new BasicEmulator();
      const gestures = emulator.getGestureHandler();

      let tapped = false;
      gestures.on('tap', () => { tapped = true; });

      gestures.simulateTap(100, 100);
      expect(tapped).toBe(true);
    });
  });
});
```

### E2E í…ŒìŠ¤íŠ¸ ì˜ˆì œ

```typescript
import { describe, test, expect } from 'bun:test';
import { BasicEmulator } from '@/system/BasicEmulator';

describe('E2E User Scenarios', () => {
  test('Complete game development workflow', async () => {
    const emulator = new BasicEmulator();
    await emulator.initialize();

    // 1. Create a simple number guessing game
    const game = [
      '10 CLS',
      '20 N = INT(RND(1) * 100) + 1',
      '30 PRINT "GUESS A NUMBER (1-100)"',
      '40 INPUT G',
      '50 IF G = N THEN PRINT "CORRECT!" : END',
      '60 IF G < N THEN PRINT "TOO LOW!"',
      '70 IF G > N THEN PRINT "TOO HIGH!"',
      '80 GOTO 40'
    ];

    // 2. Load program
    await emulator.loadProgram(game);
    expect(emulator.getProgramLines()).toHaveLength(8);

    // 3. Save to storage
    await emulator.save('GAME.BAS');
    expect(await emulator.fileExists('GAME.BAS')).toBe(true);

    // 4. Clear and reload
    emulator.executeCommand('NEW');
    expect(emulator.getProgramLines()).toHaveLength(0);

    await emulator.load('GAME.BAS');
    expect(emulator.getProgramLines()).toHaveLength(8);

    // 5. Run program (will wait for input)
    const runPromise = emulator.run();

    // 6. Simulate user input
    setTimeout(() => {
      emulator.provideInput('50');
    }, 100);

    const result = await runPromise;
    expect(result.success).toBe(true);
    expect(result.output).toContain('GUESS A NUMBER');
  });

  test('Audio composition workflow', async () => {
    const emulator = new BasicEmulator();
    await emulator.initialize();

    const composition = [
      '10 REM SIMPLE MELODY COMPOSER',
      '20 PLAY "T120 O4"',
      '30 PLAY "[CDEFG]2"',        // Repeat scale
      '40 PLAYCH 1, "T120 O2 CCC"', // Bass line
      '50 PLAY "V10 MS CDEFG"',    // Staccato ending
      '60 END'
    ];

    await emulator.loadProgram(composition);
    const result = await emulator.run();

    expect(result.success).toBe(true);

    // Verify audio channels were used
    const audioEngine = emulator.getAudioEngine();
    const stats = audioEngine.getStats();
    expect(stats.channelsUsed).toBeGreaterThan(0);
  });

  test('Mobile responsive UI workflow', async () => {
    const emulator = new BasicEmulator({
      viewport: 'mobile'
    });
    await emulator.initialize();

    // 1. Show virtual keyboard
    const keyboard = emulator.getVirtualKeyboard();
    keyboard.show();
    expect(keyboard.isVisible()).toBe(true);

    // 2. Switch to BASIC layout
    keyboard.setLayout('basic');
    expect(keyboard.getLayout()).toBe('basic');

    // 3. Type BASIC command
    keyboard.type('PRINT "HELLO"');

    // 4. Execute
    const result = await emulator.executeCommand('PRINT "HELLO"');
    expect(result.output).toBe('HELLO\n');

    // 5. Monitor performance
    const perfMonitor = emulator.getPerformanceMonitor();
    const metrics = perfMonitor.getMetrics();
    expect(metrics.fps).toBeGreaterThan(30);
  });
});
```

## ğŸ­ ëª¨í‚¹ ì „ëµ

### Web Audio API ëª¨í‚¹

```typescript
import { beforeEach, afterEach } from 'bun:test';

// Mock AudioContext
class MockAudioContext {
  currentTime = 0;
  sampleRate = 44100;
  destination = {};

  createOscillator() {
    return new MockOscillator();
  }

  createGain() {
    return new MockGainNode();
  }

  createAnalyser() {
    return new MockAnalyser();
  }
}

class MockOscillator {
  frequency = { value: 440 };
  type = 'sine';

  connect() {}
  start() {}
  stop() {}
}

class MockGainNode {
  gain = { value: 1 };

  connect() {}
}

// Setup in tests
beforeEach(() => {
  global.AudioContext = MockAudioContext as any;
  global.webkitAudioContext = MockAudioContext as any;
});
```

### Canvas API ëª¨í‚¹

```typescript
class MockCanvasContext {
  fillStyle = '#000000';
  strokeStyle = '#000000';
  lineWidth = 1;

  fillRect(x: number, y: number, w: number, h: number) {
    // Record drawing operation
  }

  strokeRect(x: number, y: number, w: number, h: number) {
    // Record drawing operation
  }

  beginPath() {}
  closePath() {}
  moveTo(x: number, y: number) {}
  lineTo(x: number, y: number) {}
  arc(x: number, y: number, r: number, start: number, end: number) {}
  fill() {}
  stroke() {}
}

beforeEach(() => {
  global.HTMLCanvasElement.prototype.getContext = function(type: string) {
    return new MockCanvasContext();
  };
});
```

### Touch Events ëª¨í‚¹

```typescript
class MockTouchEvent extends Event {
  touches: Touch[];
  changedTouches: Touch[];

  constructor(type: string, init: any) {
    super(type, init);
    this.touches = init.touches || [];
    this.changedTouches = init.changedTouches || [];
  }
}

class MockTouch {
  constructor(
    public identifier: number,
    public clientX: number,
    public clientY: number
  ) {}
}

// Create touch events
function createTouchEvent(type: string, x: number, y: number) {
  const touch = new MockTouch(0, x, y);
  return new MockTouchEvent(type, {
    touches: [touch],
    changedTouches: [touch]
  });
}
```

### localStorage ëª¨í‚¹

```typescript
class MockLocalStorage {
  private store: Record<string, string> = {};

  getItem(key: string): string | null {
    return this.store[key] || null;
  }

  setItem(key: string, value: string): void {
    this.store[key] = value;
  }

  removeItem(key: string): void {
    delete this.store[key];
  }

  clear(): void {
    this.store = {};
  }

  get length(): number {
    return Object.keys(this.store).length;
  }

  key(index: number): string | null {
    const keys = Object.keys(this.store);
    return keys[index] || null;
  }
}

beforeEach(() => {
  global.localStorage = new MockLocalStorage() as any;
});
```

## ğŸ“Š í…ŒìŠ¤íŠ¸ í†µê³„

### ì „ì²´ í…ŒìŠ¤íŠ¸ í˜„í™©

```
ì´ í…ŒìŠ¤íŠ¸ ìˆ˜: 1,400+ ê°œ
í†µê³¼ìœ¨: 95%+
ì»¤ë²„ë¦¬ì§€: 90%+
```

### ëª¨ë“ˆë³„ í…ŒìŠ¤íŠ¸ ìˆ˜

| ëª¨ë“ˆ | í…ŒìŠ¤íŠ¸ ìˆ˜ | í†µê³¼ìœ¨ | ì»¤ë²„ë¦¬ì§€ |
|------|----------|--------|----------|
| ì˜¤ë””ì˜¤ ì—”ì§„ | 97 | 100% | 95% |
| ê·¸ë˜í”½ ì—”ì§„ | 161 | 100% | 100% |
| ëª¨ë°”ì¼ ìµœì í™” | 228 | 95% | 92% |
| ì—ë””í„° | 189 | 100% | 98% |
| ë””ë²„ê±° | 58 | 100% | 90% |
| ì‹œìŠ¤í…œ í†µí•© | 116 | 98% | 88% |
| E2E ì‹œë‚˜ë¦¬ì˜¤ | 45 | 93% | N/A |
| CPU ì—ë®¬ë ˆì´í„° | 150+ | 98% | 95% |
| BASIC ì¸í„°í”„ë¦¬í„° | 200+ | 96% | 92% |
| ë©”ëª¨ë¦¬ ê´€ë¦¬ | 80+ | 100% | 97% |

### í…ŒìŠ¤íŠ¸ ì¹´í…Œê³ ë¦¬

```typescript
// ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ (Unit Tests)
- ê°œë³„ í•¨ìˆ˜/í´ë˜ìŠ¤ í…ŒìŠ¤íŠ¸
- 1,000+ í…ŒìŠ¤íŠ¸
- ì‹¤í–‰ ì‹œê°„: < 5ì´ˆ

// í†µí•© í…ŒìŠ¤íŠ¸ (Integration Tests)
- ëª¨ë“ˆ ê°„ ìƒí˜¸ì‘ìš© í…ŒìŠ¤íŠ¸
- 300+ í…ŒìŠ¤íŠ¸
- ì‹¤í–‰ ì‹œê°„: < 30ì´ˆ

// E2E í…ŒìŠ¤íŠ¸ (End-to-End Tests)
- ì‚¬ìš©ì ì‹œë‚˜ë¦¬ì˜¤ í…ŒìŠ¤íŠ¸
- 100+ í…ŒìŠ¤íŠ¸
- ì‹¤í–‰ ì‹œê°„: < 2ë¶„

// ì„±ëŠ¥ í…ŒìŠ¤íŠ¸ (Performance Tests)
- ë²¤ì¹˜ë§ˆí¬ ë° í”„ë¡œíŒŒì¼ë§
- 50+ í…ŒìŠ¤íŠ¸
- ì‹¤í–‰ ì‹œê°„: < 1ë¶„
```

## ğŸ”„ CI/CD í†µí•©

### GitHub Actions ì„¤ì •

```yaml
# .github/workflows/test.yml
name: Tests

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3

    - name: Setup Bun
      uses: oven-sh/setup-bun@v1
      with:
        bun-version: latest

    - name: Install dependencies
      run: bun install

    - name: Run tests
      run: bun test

    - name: Generate coverage report
      run: bun test --coverage

    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        files: ./coverage/coverage-final.json
        fail_ci_if_error: true
```

### Pre-commit Hooks

```bash
# .husky/pre-commit
#!/bin/sh
. "$(dirname "$0")/_/husky.sh"

# Run tests before commit
bun test

# Run linter
bun run lint

# Check TypeScript types
bun run typecheck
```

## ğŸ› íŠ¸ëŸ¬ë¸”ìŠˆíŒ…

### ì¼ë°˜ì ì¸ ë¬¸ì œ

#### 1. í…ŒìŠ¤íŠ¸ íƒ€ì„ì•„ì›ƒ

```typescript
// ë¬¸ì œ: ë¹„ë™ê¸° í…ŒìŠ¤íŠ¸ íƒ€ì„ì•„ì›ƒ
test('async test', async () => {
  await longRunningOperation();
});

// í•´ê²°: íƒ€ì„ì•„ì›ƒ ì¦ê°€
test('async test', async () => {
  await longRunningOperation();
}, { timeout: 10000 }); // 10ì´ˆ
```

#### 2. ëª¨í‚¹ ì‹¤íŒ¨

```typescript
// ë¬¸ì œ: AudioContext ëª¨í‚¹ ì•ˆë¨
test('audio test', () => {
  const audio = new AudioEngine(); // Error: AudioContext is not defined
});

// í•´ê²°: beforeEachì—ì„œ ëª¨í‚¹
beforeEach(() => {
  global.AudioContext = MockAudioContext as any;
});
```

#### 3. ë©”ëª¨ë¦¬ ëˆ„ìˆ˜

```typescript
// ë¬¸ì œ: í…ŒìŠ¤íŠ¸ í›„ ë¦¬ì†ŒìŠ¤ ì •ë¦¬ ì•ˆë¨
test('resource test', () => {
  const resource = new Resource();
  // í…ŒìŠ¤íŠ¸ ì½”ë“œ...
}); // Resource not cleaned up

// í•´ê²°: afterEach ì‚¬ìš©
let resource: Resource;

beforeEach(() => {
  resource = new Resource();
});

afterEach(() => {
  resource.dispose();
});
```

#### 4. ê²½ìŸ ì¡°ê±´ (Race Conditions)

```typescript
// ë¬¸ì œ: ë¹„ë™ê¸° ì‘ì—… ìˆœì„œ ë³´ì¥ ì•ˆë¨
test('concurrent test', async () => {
  operation1(); // Don't await
  operation2(); // Race condition!
});

// í•´ê²°: Promise.all ì‚¬ìš©
test('concurrent test', async () => {
  await Promise.all([
    operation1(),
    operation2()
  ]);
});
```

### ë””ë²„ê¹… íŒ

```bash
# 1. íŠ¹ì • í…ŒìŠ¤íŠ¸ë§Œ ì‹¤í–‰ (debugging)
bun test --test-name-pattern "should parse MML"

# 2. ìƒì„¸ ì¶œë ¥
bun test --verbose

# 3. ì‹¤íŒ¨í•œ í…ŒìŠ¤íŠ¸ë§Œ ì¬ì‹¤í–‰
bun test --only-failures

# 4. í…ŒìŠ¤íŠ¸ ë””ë²„ê±° ì‚¬ìš©
bun test --inspect-brk tests/audio/audio-engine.test.ts
```

### ì„±ëŠ¥ ìµœì í™”

```typescript
// ëŠë¦° í…ŒìŠ¤íŠ¸ ìµœì í™”
describe('Performance Tests', () => {
  // Bad: ë§¤ í…ŒìŠ¤íŠ¸ë§ˆë‹¤ ìƒì„±
  test('test 1', () => {
    const emulator = new BasicEmulator(); // Slow
  });

  test('test 2', () => {
    const emulator = new BasicEmulator(); // Slow
  });

  // Good: í•œ ë²ˆë§Œ ìƒì„±
  let emulator: BasicEmulator;

  beforeAll(() => {
    emulator = new BasicEmulator();
  });

  afterAll(() => {
    emulator.dispose();
  });

  test('test 1', () => {
    emulator.reset();
    // í…ŒìŠ¤íŠ¸...
  });

  test('test 2', () => {
    emulator.reset();
    // í…ŒìŠ¤íŠ¸...
  });
});
```

## ğŸ“š ì¶”ê°€ ìë£Œ

### í…ŒìŠ¤íŠ¸ ê´€ë ¨ ë¬¸ì„œ
- [Bun Test Runner](https://bun.sh/docs/cli/test)
- [Testing Best Practices](https://github.com/goldbergyoni/javascript-testing-best-practices)
- [Test-Driven Development](https://martinfowler.com/bliki/TestDrivenDevelopment.html)

### ê´€ë ¨ ê°€ì´ë“œ
- [ê°œë°œì ê°€ì´ë“œ](./ê°œë°œìê°€ì´ë“œ.md)
- [API ë¬¸ì„œ](./APIë¬¸ì„œ.md)
- [ê¸°ì—¬ ê°€ì´ë“œ](./ê¸°ì—¬ê°€ì´ë“œ.md)

---

**ë²„ì „**: 2.0.0
**ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸**: 2025-10-04
**í…ŒìŠ¤íŠ¸ í”„ë ˆì„ì›Œí¬**: Bun Test Runner 1.0+

