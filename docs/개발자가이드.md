# ê°œë°œì ê°€ì´ë“œ

> 6502 BASIC JavaScript ì—ë®¬ë ˆì´í„° ê°œë°œ í™˜ê²½ ì„¤ì • ë° ì•„í‚¤í…ì²˜ ê°€ì´ë“œ

## ğŸ“‹ ëª©ì°¨

1. [ê°œë°œ í™˜ê²½ ì„¤ì •](#ê°œë°œ-í™˜ê²½-ì„¤ì •)
2. [í”„ë¡œì íŠ¸ ì•„í‚¤í…ì²˜](#í”„ë¡œì íŠ¸-ì•„í‚¤í…ì²˜)
3. [ê°œë°œ ì›Œí¬í”Œë¡œìš°](#ê°œë°œ-ì›Œí¬í”Œë¡œìš°)
4. [ì½”ë”© ê·œì¹™](#ì½”ë”©-ê·œì¹™)
5. [ë””ë²„ê¹… ê°€ì´ë“œ](#ë””ë²„ê¹…-ê°€ì´ë“œ)
6. [ì„±ëŠ¥ ìµœì í™”](#ì„±ëŠ¥-ìµœì í™”)
7. [íŠ¸ëŸ¬ë¸”ìŠˆíŒ…](#íŠ¸ëŸ¬ë¸”ìŠˆíŒ…)

## ğŸš€ ê°œë°œ í™˜ê²½ ì„¤ì •

### í•„ìš” ì¡°ê±´

- **Bun** 1.0.0 ì´ìƒ - JavaScript/TypeScript ëŸ°íƒ€ì„
- **Node.js** 18.0.0 ì´ìƒ (ì„ íƒì )
- **Git** 2.20.0 ì´ìƒ
- **í˜„ëŒ€ì  ì½”ë“œ ì—ë””í„°** (VS Code ê¶Œì¥)

### VS Code í™•ì¥ í”„ë¡œê·¸ë¨ (ê¶Œì¥)

```json
{
  "recommendations": [
    "esbenp.prettier-vscode",
    "bradlc.vscode-tailwindcss",
    "ms-vscode.vscode-typescript-next",
    "formulahendry.auto-rename-tag",
    "christian-kohler.path-intellisense",
    "ms-vscode.test-adapter-converter"
  ]
}
```

### í”„ë¡œì íŠ¸ í´ë¡  ë° ì„¤ì •

```bash
# ì €ì¥ì†Œ í´ë¡ 
git clone https://github.com/your-username/6502-basic-js.git
cd 6502-basic-js/jsbasic

# ì˜ì¡´ì„± ì„¤ì¹˜
bun install

# ê°œë°œ í™˜ê²½ í™•ì¸
bun run lint    # TypeScript íƒ€ì… ê²€ì‚¬
bun run test    # ëª¨ë“  í…ŒìŠ¤íŠ¸ ì‹¤í–‰
bun run dev     # ê°œë°œ ì„œë²„ ì‹œì‘
```

### í™˜ê²½ ë³€ìˆ˜ ì„¤ì •

`.env` íŒŒì¼ ìƒì„±:

```bash
# ê°œë°œ í™˜ê²½ ì„¤ì •
NODE_ENV=development
DEV_SERVER_PORT=3000
DEBUG_MODE=true

# ë¹Œë“œ ì„¤ì •
BUILD_ANALYZER=false
MINIFY=false

# í…ŒìŠ¤íŠ¸ ì„¤ì •
TEST_TIMEOUT=10000
COVERAGE_THRESHOLD=90
```

## ğŸ—ï¸ í”„ë¡œì íŠ¸ ì•„í‚¤í…ì²˜

### ê³„ì¸µë³„ ì•„í‚¤í…ì²˜

```mermaid
graph TB
    UI[ì‚¬ìš©ì ì¸í„°í˜ì´ìŠ¤ ê³„ì¸µ]
    BASIC[BASIC ì¸í„°í”„ë¦¬í„° ê³„ì¸µ]
    CPU[6502 CPU ì—ë®¬ë ˆì´ì…˜ ê³„ì¸µ]
    MEM[ë©”ëª¨ë¦¬ ê´€ë¦¬ ê³„ì¸µ]
    IO[I/O ì‹œìŠ¤í…œ ê³„ì¸µ]
    
    UI --> BASIC
    BASIC --> CPU
    CPU --> MEM
    CPU --> IO
    BASIC --> MEM
    UI --> IO
```

### ëª¨ë“ˆ ì˜ì¡´ì„± ê·¸ë˜í”„

```
src/
â”œâ”€â”€ index.ts           # ë©”ì¸ ì—”íŠ¸ë¦¬ í¬ì¸íŠ¸
â”œâ”€â”€ types/             # ê³µí†µ íƒ€ì… ì •ì˜
â”œâ”€â”€ utils/             # ê³µí†µ ìœ í‹¸ë¦¬í‹°
â”œâ”€â”€ cpu/               # CPU ì—ë®¬ë ˆì´í„°
â”‚   â”œâ”€â”€ cpu.ts         # CPU í´ë˜ìŠ¤ (ì½”ì–´)
â”‚   â”œâ”€â”€ instructions.ts # ëª…ë ¹ì–´ êµ¬í˜„
â”‚   â”œâ”€â”€ addressing.ts  # ì£¼ì†Œ ì§€ì • ëª¨ë“œ
â”‚   â””â”€â”€ opcodes.ts     # ì˜¤í”¼ì½”ë“œ í…Œì´ë¸”
â”œâ”€â”€ memory/            # ë©”ëª¨ë¦¬ ê´€ë¦¬
â”‚   â”œâ”€â”€ memory.ts      # ë©”ëª¨ë¦¬ ë§¤ë‹ˆì €
â”‚   â”œâ”€â”€ heap.ts        # í™ ê´€ë¦¬
â”‚   â””â”€â”€ garbage.ts     # ê°€ë¹„ì§€ ì»¬ë ‰í„°
â”œâ”€â”€ basic/             # BASIC ì¸í„°í”„ë¦¬í„°
â”‚   â”œâ”€â”€ parser.ts      # êµ¬ë¬¸ ë¶„ì„ê¸°
â”‚   â”œâ”€â”€ interpreter.ts # ì‹¤í–‰ ì—”ì§„
â”‚   â”œâ”€â”€ variables.ts   # ë³€ìˆ˜ ê´€ë¦¬
â”‚   â”œâ”€â”€ functions.ts   # ë‚´ì¥ í•¨ìˆ˜
â”‚   â””â”€â”€ statements.ts  # ëª…ë ¹ë¬¸ ì²˜ë¦¬
â”œâ”€â”€ math/              # ìˆ˜í•™ íŒ¨í‚¤ì§€
â”‚   â”œâ”€â”€ float.ts       # ë¶€ë™ì†Œìˆ˜ì 
â”‚   â”œâ”€â”€ trig.ts        # ì‚¼ê°í•¨ìˆ˜
â”‚   â””â”€â”€ utils.ts       # ìˆ˜í•™ ìœ í‹¸ë¦¬í‹°
â”œâ”€â”€ io/                # ì…ì¶œë ¥ ì‹œìŠ¤í…œ
â”‚   â”œâ”€â”€ terminal.ts    # í„°ë¯¸ë„ ì¸í„°í˜ì´ìŠ¤
â”‚   â”œâ”€â”€ keyboard.ts    # í‚¤ë³´ë“œ ì²˜ë¦¬
â”‚   â””â”€â”€ storage.ts     # íŒŒì¼ ì €ì¥/ë¡œë“œ
â””â”€â”€ ui/                # ì‚¬ìš©ì ì¸í„°í˜ì´ìŠ¤
    â”œâ”€â”€ editor.ts      # ì½”ë“œ ì—ë””í„°
    â”œâ”€â”€ console.ts     # ì½˜ì†” ì°½
    â””â”€â”€ controls.ts    # ì œì–´ ë²„íŠ¼
```

### TypeScript íƒ€ì… ì‹œìŠ¤í…œ

#### í•µì‹¬ ì¸í„°í˜ì´ìŠ¤

```typescript
// CPU ë ˆì§€ìŠ¤í„° íƒ€ì…
interface CPURegisters {
  A: number;      // ëˆ„ì‚°ê¸° (0-255)
  X: number;      // X ì¸ë±ìŠ¤ ë ˆì§€ìŠ¤í„° (0-255)
  Y: number;      // Y ì¸ë±ìŠ¤ ë ˆì§€ìŠ¤í„° (0-255)
  SP: number;     // ìŠ¤íƒ í¬ì¸í„° (0-255)
  PC: number;     // í”„ë¡œê·¸ë¨ ì¹´ìš´í„° (0-65535)
  P: number;      // ìƒíƒœ ë ˆì§€ìŠ¤í„° (í”Œë˜ê·¸)
}

// ë©”ëª¨ë¦¬ ì¸í„°í˜ì´ìŠ¤
interface MemoryManager {
  read(address: number): number;
  write(address: number, value: number): void;
  readWord(address: number): number;
  writeWord(address: number, value: number): void;
  dump(start: number, length: number): MemoryDump;
}

// BASIC ë³€ìˆ˜ íƒ€ì…
type BasicValue = number | string | BasicArray;
interface BasicVariable {
  name: string;
  type: 'number' | 'string' | 'array';
  value: BasicValue;
}
```

#### ì œë„¤ë¦­ ë° ìœ í‹¸ë¦¬í‹° íƒ€ì…

```typescript
// ì´ë²¤íŠ¸ ì‹œìŠ¤í…œ
type EventHandler<T = any> = (data: T) => void;
interface EventEmitter<T extends Record<string, any>> {
  on<K extends keyof T>(event: K, handler: EventHandler<T[K]>): void;
  emit<K extends keyof T>(event: K, data: T[K]): void;
  off<K extends keyof T>(event: K, handler: EventHandler<T[K]>): void;
}

// ìƒíƒœ ê´€ë¦¬
type SystemState = 'stopped' | 'running' | 'paused' | 'error';
interface StateMachine<T extends string> {
  currentState: T;
  transition(newState: T): boolean;
  canTransition(fromState: T, toState: T): boolean;
}

// ì„±ëŠ¥ ë©”íŠ¸ë¦­
interface PerformanceMetrics {
  cyclesPerSecond: number;
  memoryUsage: number;
  executionTime: number;
  lastUpdate: number;
}
```

## ğŸ”„ ê°œë°œ ì›Œí¬í”Œë¡œìš°

### Git ë¸Œëœì¹˜ ì „ëµ

```
main
â”œâ”€â”€ develop              # ê°œë°œ í†µí•© ë¸Œëœì¹˜
â”‚   â”œâ”€â”€ feature/cpu-core    # CPU êµ¬í˜„
â”‚   â”œâ”€â”€ feature/basic-parser # BASIC íŒŒì„œ
â”‚   â”œâ”€â”€ feature/ui-terminal  # í„°ë¯¸ë„ UI
â”‚   â””â”€â”€ feature/math-lib     # ìˆ˜í•™ ë¼ì´ë¸ŒëŸ¬ë¦¬
â”œâ”€â”€ hotfix/critical-bug  # ê¸´ê¸‰ ìˆ˜ì •
â””â”€â”€ release/v1.0.0       # ë¦´ë¦¬ì¦ˆ ì¤€ë¹„
```

### ì»¤ë°‹ ë©”ì‹œì§€ ê·œì¹™

```bash
# íƒ€ì…(ë²”ìœ„): ì„¤ëª…
feat(cpu): 6502 ADD ëª…ë ¹ì–´ êµ¬í˜„
fix(parser): BASIC FOR ë£¨í”„ íŒŒì‹± ì˜¤ë¥˜ ìˆ˜ì •
docs(readme): ì„¤ì¹˜ ê°€ì´ë“œ ì—…ë°ì´íŠ¸
test(memory): ë©”ëª¨ë¦¬ ê´€ë¦¬ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ì¶”ê°€
perf(cpu): ëª…ë ¹ì–´ ì‹¤í–‰ ì„±ëŠ¥ 20% í–¥ìƒ
refactor(basic): ë³€ìˆ˜ ê´€ë¦¬ ì½”ë“œ ë¦¬íŒ©í„°ë§
```

### ê°œë°œ ì‚¬ì´í´

1. **ê³„íš**: GitHub Issuesë¡œ ì‘ì—… ê³„íš
2. **ê°œë°œ**: ê¸°ëŠ¥ ë¸Œëœì¹˜ì—ì„œ êµ¬í˜„
3. **í…ŒìŠ¤íŠ¸**: `bun run test` ì‹¤í–‰
4. **ê²€í† **: Pull Request ìƒì„±
5. **í†µí•©**: develop ë¸Œëœì¹˜ ë¨¸ì§€
6. **ë°°í¬**: main ë¸Œëœì¹˜ë¡œ ë¦´ë¦¬ì¦ˆ

## ğŸ“ ì½”ë”© ê·œì¹™

### TypeScript ìŠ¤íƒ€ì¼ ê°€ì´ë“œ

```typescript
// âœ… ì¢‹ì€ ì˜ˆì œ
interface CPUInstruction {
  readonly opcode: number;
  readonly mnemonic: string;
  readonly cycles: number;
  execute(cpu: CPU6502): void;
}

class CPU6502 implements CPUInterface {
  private readonly memory: MemoryManager;
  private registers: CPURegisters;
  
  constructor(memory: MemoryManager) {
    this.memory = memory;
    this.registers = this.initializeRegisters();
  }
  
  public step(): number {
    const opcode = this.fetchByte();
    const instruction = this.opcodes[opcode];
    
    if (!instruction) {
      throw new CPUError(`Unknown opcode: 0x${opcode.toString(16)}`);
    }
    
    instruction.execute(this);
    return instruction.cycles;
  }
  
  private fetchByte(): number {
    return this.memory.read(this.registers.PC++);
  }
}

// âŒ ë‚˜ìœ ì˜ˆì œ
class cpu {  // í´ë˜ìŠ¤ëª…ì€ PascalCase
  mem: any;  // any íƒ€ì… ì§€ì–‘
  regs = {}; // íƒ€ì… ëª…ì‹œ í•„ìš”
  
  run() {    // ë©”ì„œë“œ ì ‘ê·¼ì„± ëª…ì‹œ
    // êµ¬í˜„...
  }
}
```

### ë„¤ì´ë° ê·œì¹™

```typescript
// ë³€ìˆ˜ ë° í•¨ìˆ˜: camelCase
const memorySize = 65536;
function calculateAddress() { }

// í´ë˜ìŠ¤: PascalCase
class BasicInterpreter { }
class MemoryManager { }

// ìƒìˆ˜: UPPER_SNAKE_CASE
const MAX_MEMORY_SIZE = 65536;
const CPU_FREQ_MHZ = 1;

// ì¸í„°í˜ì´ìŠ¤: PascalCase (I ì ‘ë‘ì‚¬ ì§€ì–‘)
interface CPUState { }
interface MemoryBank { }

// íƒ€ì…: PascalCase
type AddressingMode = 'immediate' | 'absolute' | 'zeroPage';
type SystemEvent = 'reset' | 'interrupt' | 'break';

// ì—´ê±°í˜•: PascalCase, ê°’ì€ UPPER_SNAKE_CASE
enum CPUFlag {
  CARRY = 0x01,
  ZERO = 0x02,
  INTERRUPT = 0x04
}
```

### ì—ëŸ¬ ì²˜ë¦¬ íŒ¨í„´

```typescript
// ì‚¬ìš©ì ì •ì˜ ì—ëŸ¬ í´ë˜ìŠ¤
class CPUError extends Error {
  constructor(
    message: string,
    public readonly code: string,
    public readonly address?: number
  ) {
    super(message);
    this.name = 'CPUError';
  }
}

class BasicError extends Error {
  constructor(
    message: string,
    public readonly lineNumber: number,
    public readonly column?: number
  ) {
    super(message);
    this.name = 'BasicError';
  }
}

// ì—ëŸ¬ ì²˜ë¦¬ ì˜ˆì œ
try {
  cpu.execute(instruction);
} catch (error) {
  if (error instanceof CPUError) {
    console.error(`CPU ì—ëŸ¬ [${error.code}]: ${error.message}`);
    if (error.address !== undefined) {
      console.error(`ì£¼ì†Œ: 0x${error.address.toString(16)}`);
    }
  } else {
    console.error('ì˜ˆìƒì¹˜ ëª»í•œ ì—ëŸ¬:', error);
  }
}
```

## ğŸ”§ ë””ë²„ê¹… ê°€ì´ë“œ

### ë””ë²„ê¹… ë„êµ¬

```typescript
// ë¡œê¹… ìœ í‹¸ë¦¬í‹°
class Logger {
  static debug(message: string, data?: any): void {
    if (process.env.DEBUG_MODE === 'true') {
      console.debug(`[DEBUG] ${message}`, data);
    }
  }
  
  static cpu(message: string, registers?: CPURegisters): void {
    if (process.env.DEBUG_CPU === 'true') {
      console.log(`[CPU] ${message}`);
      if (registers) {
        console.table(registers);
      }
    }
  }
  
  static basic(message: string, context?: any): void {
    if (process.env.DEBUG_BASIC === 'true') {
      console.log(`[BASIC] ${message}`, context);
    }
  }
}

// ì‚¬ìš© ì˜ˆì œ
Logger.cpu('ëª…ë ¹ì–´ ì‹¤í–‰', cpu.registers);
Logger.basic('ë³€ìˆ˜ í• ë‹¹', { name: 'A', value: 42 });
```

### ì„±ëŠ¥ í”„ë¡œíŒŒì¼ë§

```typescript
class Profiler {
  private static timers = new Map<string, number>();
  
  static start(label: string): void {
    this.timers.set(label, performance.now());
  }
  
  static end(label: string): number {
    const start = this.timers.get(label);
    if (!start) return 0;
    
    const duration = performance.now() - start;
    console.log(`[PERF] ${label}: ${duration.toFixed(2)}ms`);
    this.timers.delete(label);
    return duration;
  }
  
  static measure<T>(label: string, fn: () => T): T {
    this.start(label);
    try {
      return fn();
    } finally {
      this.end(label);
    }
  }
}

// ì‚¬ìš© ì˜ˆì œ
const result = Profiler.measure('CPU ì‹¤í–‰', () => {
  return cpu.executeProgram(program);
});
```

### ë©”ëª¨ë¦¬ ë¤í”„ ë„êµ¬

```typescript
function dumpMemory(
  memory: MemoryManager, 
  start: number, 
  length: number
): string {
  let output = `ë©”ëª¨ë¦¬ ë¤í”„ (0x${start.toString(16)} - 0x${(start + length).toString(16)}):\n`;
  
  for (let i = 0; i < length; i += 16) {
    const addr = start + i;
    let line = `0x${addr.toString(16).padStart(4, '0')}: `;
    
    // 16ë°”ì´íŠ¸ í—¥ì‚¬ í‘œì‹œ
    for (let j = 0; j < 16 && i + j < length; j++) {
      const value = memory.read(addr + j);
      line += `${value.toString(16).padStart(2, '0')} `;
    }
    
    // ASCII í‘œì‹œ
    line += ' |';
    for (let j = 0; j < 16 && i + j < length; j++) {
      const value = memory.read(addr + j);
      const char = value >= 32 && value <= 126 ? String.fromCharCode(value) : '.';
      line += char;
    }
    line += '|';
    
    output += line + '\n';
  }
  
  return output;
}
```

## âš¡ ì„±ëŠ¥ ìµœì í™”

### CPU ìµœì í™” ê¸°ë²•

```typescript
// ëª…ë ¹ì–´ ì‹¤í–‰ ìµœì í™”
class OptimizedCPU extends CPU6502 {
  private instructionCache = new Map<number, CPUInstruction>();
  
  protected executeInstruction(opcode: number): void {
    // ìºì‹œëœ ëª…ë ¹ì–´ ì‚¬ìš©
    let instruction = this.instructionCache.get(opcode);
    
    if (!instruction) {
      instruction = this.opcodes[opcode];
      this.instructionCache.set(opcode, instruction);
    }
    
    instruction.execute(this);
  }
}

// ë©”ëª¨ë¦¬ ì ‘ê·¼ ìµœì í™”
class FastMemory implements MemoryManager {
  private cache = new Map<number, number>();
  
  read(address: number): number {
    // í˜ì´ì§€ ì œë¡œëŠ” ìºì‹œ ì‚¬ìš©
    if (address < 256) {
      let value = this.cache.get(address);
      if (value === undefined) {
        value = this.memory[address];
        this.cache.set(address, value);
      }
      return value;
    }
    
    return this.memory[address];
  }
}
```

### BASIC íŒŒì„œ ìµœì í™”

```typescript
// í† í° ìºì‹±
class TokenCache {
  private cache = new Map<string, Token[]>();
  
  tokenize(line: string): Token[] {
    let tokens = this.cache.get(line);
    
    if (!tokens) {
      tokens = this.parser.tokenize(line);
      this.cache.set(line, tokens);
    }
    
    return tokens;
  }
}

// í‘œí˜„ì‹ ì»´íŒŒì¼
class ExpressionCompiler {
  compile(expression: string): CompiledExpression {
    // BASIC í‘œí˜„ì‹ì„ JavaScript í•¨ìˆ˜ë¡œ ì»´íŒŒì¼
    const jsCode = this.translateToJS(expression);
    return new Function('vars', `return ${jsCode}`) as CompiledExpression;
  }
}
```

## ğŸ› íŠ¸ëŸ¬ë¸”ìŠˆíŒ…

### ì¼ë°˜ì ì¸ ë¬¸ì œë“¤

#### 1. TypeScript ì»´íŒŒì¼ ì—ëŸ¬

```bash
# ë¬¸ì œ: íƒ€ì… ì—ëŸ¬
error TS2322: Type 'number' is not assignable to type 'string'

# í•´ê²°: íƒ€ì… ê°€ë“œ ì‚¬ìš©
function isString(value: unknown): value is string {
  return typeof value === 'string';
}

if (isString(userInput)) {
  // ì—¬ê¸°ì„œ userInputì€ stringìœ¼ë¡œ íƒ€ì… narrowing
  console.log(userInput.toUpperCase());
}
```

#### 2. ë©”ëª¨ë¦¬ ëˆ„ìˆ˜

```typescript
// ë¬¸ì œ: ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì •ë¦¬ ì•ˆë¨
class Component {
  constructor() {
    window.addEventListener('resize', this.handleResize);
  }
  
  // í•´ê²°: cleanup ë©”ì„œë“œ ì¶”ê°€
  destroy(): void {
    window.removeEventListener('resize', this.handleResize);
  }
  
  private handleResize = (): void => {
    // í•¸ë“¤ëŸ¬ ë¡œì§
  }
}
```

#### 3. ì„±ëŠ¥ ë¬¸ì œ

```typescript
// ë¬¸ì œ: ë§¤ í”„ë ˆì„ë§ˆë‹¤ ê°ì²´ ìƒì„±
function render(): void {
  const config = { width: 800, height: 600 }; // âŒ ë§¤ë²ˆ ìƒì„±
  drawScreen(config);
}

// í•´ê²°: ê°ì²´ ì¬ì‚¬ìš©
const SCREEN_CONFIG = { width: 800, height: 600 }; // âœ… ìƒìˆ˜ë¡œ ì„ ì–¸

function render(): void {
  drawScreen(SCREEN_CONFIG);
}
```

### ë””ë²„ê¹… ì²´í¬ë¦¬ìŠ¤íŠ¸

- [ ] ì½˜ì†”ì—ì„œ TypeScript ì—ëŸ¬ í™•ì¸
- [ ] ë¸Œë¼ìš°ì € ê°œë°œì ë„êµ¬ì—ì„œ JavaScript ì—ëŸ¬ í™•ì¸  
- [ ] ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ëª¨ë‹ˆí„°ë§
- [ ] ì„±ëŠ¥ í”„ë¡œíŒŒì¼ë§ ì‹¤í–‰
- [ ] ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ì‹¤í–‰
- [ ] í†µí•© í…ŒìŠ¤íŠ¸ ì‹¤í–‰

### ë¡œê·¸ ë ˆë²¨ ì„¤ì •

```typescript
enum LogLevel {
  ERROR = 0,
  WARN = 1,
  INFO = 2,
  DEBUG = 3
}

class Logger {
  private static level = LogLevel.INFO;
  
  static setLevel(level: LogLevel): void {
    this.level = level;
  }
  
  static debug(message: string): void {
    if (this.level >= LogLevel.DEBUG) {
      console.debug(`[DEBUG] ${message}`);
    }
  }
  
  static info(message: string): void {
    if (this.level >= LogLevel.INFO) {
      console.info(`[INFO] ${message}`);
    }
  }
}

// í™˜ê²½ë³„ ë¡œê·¸ ë ˆë²¨ ì„¤ì •
if (process.env.NODE_ENV === 'development') {
  Logger.setLevel(LogLevel.DEBUG);
} else {
  Logger.setLevel(LogLevel.WARN);
}
```

## ğŸ§ª í…ŒìŠ¤íŠ¸ ì‘ì„± ê°€ì´ë“œ

### ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ íŒ¨í„´

```typescript
describe('CPU6502', () => {
  let cpu: CPU6502;
  let memory: MemoryManager;
  
  beforeEach(() => {
    memory = new MemoryManager();
    cpu = new CPU6502(memory);
    cpu.reset();
  });
  
  describe('LDA ëª…ë ¹ì–´', () => {
    it('ì¦‰ì‹œ ì£¼ì†Œ ì§€ì • ëª¨ë“œë¡œ ëˆ„ì‚°ê¸°ì— ê°’ì„ ë¡œë“œí•´ì•¼ í•¨', () => {
      // Given: LDA #$42 ëª…ë ¹ì–´ ì„¤ì •
      memory.write(0x0000, 0xA9); // LDA ì¦‰ì‹œ ì£¼ì†Œ ì§€ì •
      memory.write(0x0001, 0x42); // ê°’ 0x42
      
      // When: ëª…ë ¹ì–´ ì‹¤í–‰
      cpu.step();
      
      // Then: ëˆ„ì‚°ê¸°ì— 0x42ê°€ ë¡œë“œë˜ì–´ì•¼ í•¨
      expect(cpu.registers.A).toBe(0x42);
      expect(cpu.registers.PC).toBe(0x0002);
      expect(cpu.getFlag(CPUFlag.ZERO)).toBe(false);
      expect(cpu.getFlag(CPUFlag.NEGATIVE)).toBe(false);
    });
  });
});
```

### í†µí•© í…ŒìŠ¤íŠ¸ íŒ¨í„´

```typescript
describe('BASIC ì¸í„°í”„ë¦¬í„° í†µí•© í…ŒìŠ¤íŠ¸', () => {
  let system: Basic6502System;
  
  beforeEach(() => {
    system = new Basic6502System();
  });
  
  it('ê°„ë‹¨í•œ PRINT í”„ë¡œê·¸ë¨ì„ ì‹¤í–‰í•  ìˆ˜ ìˆì–´ì•¼ í•¨', async () => {
    // Given
    const program = [
      '10 PRINT "HELLO WORLD"',
      '20 END'
    ];
    
    // When
    system.loadProgram(program);
    const output = await system.run();
    
    // Then
    expect(output).toContain('HELLO WORLD');
  });
});
```

ì´ ê°€ì´ë“œë¥¼ í†µí•´ 6502 BASIC JavaScript ì—ë®¬ë ˆì´í„° ê°œë°œì— íš¨ìœ¨ì ìœ¼ë¡œ ì°¸ì—¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì¶”ê°€ ì§ˆë¬¸ì´ë‚˜ ê°œì„  ì‚¬í•­ì´ ìˆë‹¤ë©´ ì–¸ì œë“ ì§€ ë¬¸ì˜í•´ ì£¼ì„¸ìš”!