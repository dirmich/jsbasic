# 개발자 가이드

> 6502 BASIC JavaScript 에뮬레이터 개발 환경 설정 및 아키텍처 가이드

## 📋 목차

1. [개발 환경 설정](#개발-환경-설정)
2. [프로젝트 아키텍처](#프로젝트-아키텍처)
3. [개발 워크플로우](#개발-워크플로우)
4. [코딩 규칙](#코딩-규칙)
5. [디버깅 가이드](#디버깅-가이드)
6. [성능 최적화](#성능-최적화)
7. [트러블슈팅](#트러블슈팅)

## 🚀 개발 환경 설정

### 필요 조건

- **Bun** 1.0.0 이상 - JavaScript/TypeScript 런타임
- **Node.js** 18.0.0 이상 (선택적)
- **Git** 2.20.0 이상
- **현대적 코드 에디터** (VS Code 권장)
- **현대적 웹 브라우저** (Chrome 90+, Safari 14+, Firefox 88+, Edge 90+)

### VS Code 확장 프로그램 (권장)

```json
{
  "recommendations": [
    "esbenp.prettier-vscode",
    "bradlc.vscode-tailwindcss",
    "ms-vscode.vscode-typescript-next",
    "formulahendry.auto-rename-tag",
    "christian-kohler.path-intellisense",
    "ms-vscode.test-adapter-converter"
  ]
}
```

### 프로젝트 클론 및 설정

```bash
# 저장소 클론
git clone https://github.com/your-username/6502-basic-js.git
cd 6502-basic-js/jsbasic

# 의존성 설치
bun install

# 개발 환경 확인
bun run lint    # TypeScript 타입 검사
bun run test    # 모든 테스트 실행
bun run dev     # 개발 서버 시작
```

### 환경 변수 설정

`.env` 파일 생성:

```bash
# 개발 환경 설정
NODE_ENV=development
DEV_SERVER_PORT=3000
DEBUG_MODE=true

# 빌드 설정
BUILD_ANALYZER=false
MINIFY=false

# 테스트 설정
TEST_TIMEOUT=10000
COVERAGE_THRESHOLD=90
```

## 🏗️ 프로젝트 아키텍처

### 계층별 아키텍처

```mermaid
graph TB
    UI[사용자 인터페이스 계층]
    BASIC[BASIC 인터프리터 계층]
    CPU[6502 CPU 에뮬레이션 계층]
    MEM[메모리 관리 계층]
    IO[I/O 시스템 계층]
    
    UI --> BASIC
    BASIC --> CPU
    CPU --> MEM
    CPU --> IO
    BASIC --> MEM
    UI --> IO
```

### 모듈 의존성 그래프

```
src/
├── index.ts           # 메인 엔트리 포인트
├── types/             # 공통 타입 정의
├── utils/             # 공통 유틸리티
├── cpu/               # CPU 에뮬레이터
│   ├── cpu.ts         # CPU 클래스 (코어)
│   ├── instructions.ts # 명령어 구현
│   ├── addressing.ts  # 주소 지정 모드
│   └── opcodes.ts     # 오피코드 테이블
├── memory/            # 메모리 관리
│   ├── memory.ts      # 메모리 매니저
│   ├── heap.ts        # 힙 관리
│   └── garbage.ts     # 가비지 컬렉터
├── basic/             # BASIC 인터프리터
│   ├── parser.ts      # 구문 분석기
│   ├── interpreter.ts # 실행 엔진
│   ├── variables.ts   # 변수 관리
│   ├── functions.ts   # 내장 함수
│   └── statements.ts  # 명령문 처리
├── math/              # 수학 패키지
│   ├── float.ts       # 부동소수점
│   ├── trig.ts        # 삼각함수
│   └── utils.ts       # 수학 유틸리티
├── io/                # 입출력 시스템
│   ├── terminal.ts    # 터미널 인터페이스
│   ├── keyboard.ts    # 키보드 처리
│   └── storage.ts     # 파일 저장/로드
└── ui/                # 사용자 인터페이스
    ├── editor.ts      # 코드 에디터
    ├── console.ts     # 콘솔 창
    └── controls.ts    # 제어 버튼
```

### TypeScript 타입 시스템

#### 핵심 인터페이스

```typescript
// CPU 레지스터 타입
interface CPURegisters {
  A: number;      // 누산기 (0-255)
  X: number;      // X 인덱스 레지스터 (0-255)
  Y: number;      // Y 인덱스 레지스터 (0-255)
  SP: number;     // 스택 포인터 (0-255)
  PC: number;     // 프로그램 카운터 (0-65535)
  P: number;      // 상태 레지스터 (플래그)
}

// 메모리 인터페이스
interface MemoryManager {
  read(address: number): number;
  write(address: number, value: number): void;
  readWord(address: number): number;
  writeWord(address: number, value: number): void;
  dump(start: number, length: number): MemoryDump;
}

// BASIC 변수 타입
type BasicValue = number | string | BasicArray;
interface BasicVariable {
  name: string;
  type: 'number' | 'string' | 'array';
  value: BasicValue;
}
```

#### 제네릭 및 유틸리티 타입

```typescript
// 이벤트 시스템
type EventHandler<T = any> = (data: T) => void;
interface EventEmitter<T extends Record<string, any>> {
  on<K extends keyof T>(event: K, handler: EventHandler<T[K]>): void;
  emit<K extends keyof T>(event: K, data: T[K]): void;
  off<K extends keyof T>(event: K, handler: EventHandler<T[K]>): void;
}

// 상태 관리
type SystemState = 'stopped' | 'running' | 'paused' | 'error';
interface StateMachine<T extends string> {
  currentState: T;
  transition(newState: T): boolean;
  canTransition(fromState: T, toState: T): boolean;
}

// 성능 메트릭
interface PerformanceMetrics {
  cyclesPerSecond: number;
  memoryUsage: number;
  executionTime: number;
  lastUpdate: number;
}
```

## 🔄 개발 워크플로우

### Git 브랜치 전략

```
main
├── develop              # 개발 통합 브랜치
│   ├── feature/cpu-core    # CPU 구현
│   ├── feature/basic-parser # BASIC 파서
│   ├── feature/ui-terminal  # 터미널 UI
│   └── feature/math-lib     # 수학 라이브러리
├── hotfix/critical-bug  # 긴급 수정
└── release/v1.0.0       # 릴리즈 준비
```

### 커밋 메시지 규칙

```bash
# 타입(범위): 설명
feat(cpu): 6502 ADD 명령어 구현
fix(parser): BASIC FOR 루프 파싱 오류 수정
docs(readme): 설치 가이드 업데이트
test(memory): 메모리 관리 단위 테스트 추가
perf(cpu): 명령어 실행 성능 20% 향상
refactor(basic): 변수 관리 코드 리팩터링
```

### 개발 사이클

1. **계획**: GitHub Issues로 작업 계획
2. **개발**: 기능 브랜치에서 구현
3. **테스트**: `bun run test` 실행
4. **검토**: Pull Request 생성
5. **통합**: develop 브랜치 머지
6. **배포**: main 브랜치로 릴리즈

## 📝 코딩 규칙

### TypeScript 스타일 가이드

```typescript
// ✅ 좋은 예제
interface CPUInstruction {
  readonly opcode: number;
  readonly mnemonic: string;
  readonly cycles: number;
  execute(cpu: CPU6502): void;
}

class CPU6502 implements CPUInterface {
  private readonly memory: MemoryManager;
  private registers: CPURegisters;
  
  constructor(memory: MemoryManager) {
    this.memory = memory;
    this.registers = this.initializeRegisters();
  }
  
  public step(): number {
    const opcode = this.fetchByte();
    const instruction = this.opcodes[opcode];
    
    if (!instruction) {
      throw new CPUError(`Unknown opcode: 0x${opcode.toString(16)}`);
    }
    
    instruction.execute(this);
    return instruction.cycles;
  }
  
  private fetchByte(): number {
    return this.memory.read(this.registers.PC++);
  }
}

// ❌ 나쁜 예제
class cpu {  // 클래스명은 PascalCase
  mem: any;  // any 타입 지양
  regs = {}; // 타입 명시 필요
  
  run() {    // 메서드 접근성 명시
    // 구현...
  }
}
```

### 네이밍 규칙

```typescript
// 변수 및 함수: camelCase
const memorySize = 65536;
function calculateAddress() { }

// 클래스: PascalCase
class BasicInterpreter { }
class MemoryManager { }

// 상수: UPPER_SNAKE_CASE
const MAX_MEMORY_SIZE = 65536;
const CPU_FREQ_MHZ = 1;

// 인터페이스: PascalCase (I 접두사 지양)
interface CPUState { }
interface MemoryBank { }

// 타입: PascalCase
type AddressingMode = 'immediate' | 'absolute' | 'zeroPage';
type SystemEvent = 'reset' | 'interrupt' | 'break';

// 열거형: PascalCase, 값은 UPPER_SNAKE_CASE
enum CPUFlag {
  CARRY = 0x01,
  ZERO = 0x02,
  INTERRUPT = 0x04
}
```

### 에러 처리 패턴

```typescript
// 사용자 정의 에러 클래스
class CPUError extends Error {
  constructor(
    message: string,
    public readonly code: string,
    public readonly address?: number
  ) {
    super(message);
    this.name = 'CPUError';
  }
}

class BasicError extends Error {
  constructor(
    message: string,
    public readonly lineNumber: number,
    public readonly column?: number
  ) {
    super(message);
    this.name = 'BasicError';
  }
}

// 에러 처리 예제
try {
  cpu.execute(instruction);
} catch (error) {
  if (error instanceof CPUError) {
    console.error(`CPU 에러 [${error.code}]: ${error.message}`);
    if (error.address !== undefined) {
      console.error(`주소: 0x${error.address.toString(16)}`);
    }
  } else {
    console.error('예상치 못한 에러:', error);
  }
}
```

## 🔧 디버깅 가이드

### 디버깅 도구

```typescript
// 로깅 유틸리티
class Logger {
  static debug(message: string, data?: any): void {
    if (process.env.DEBUG_MODE === 'true') {
      console.debug(`[DEBUG] ${message}`, data);
    }
  }
  
  static cpu(message: string, registers?: CPURegisters): void {
    if (process.env.DEBUG_CPU === 'true') {
      console.log(`[CPU] ${message}`);
      if (registers) {
        console.table(registers);
      }
    }
  }
  
  static basic(message: string, context?: any): void {
    if (process.env.DEBUG_BASIC === 'true') {
      console.log(`[BASIC] ${message}`, context);
    }
  }
}

// 사용 예제
Logger.cpu('명령어 실행', cpu.registers);
Logger.basic('변수 할당', { name: 'A', value: 42 });
```

### 성능 프로파일링

```typescript
class Profiler {
  private static timers = new Map<string, number>();
  
  static start(label: string): void {
    this.timers.set(label, performance.now());
  }
  
  static end(label: string): number {
    const start = this.timers.get(label);
    if (!start) return 0;
    
    const duration = performance.now() - start;
    console.log(`[PERF] ${label}: ${duration.toFixed(2)}ms`);
    this.timers.delete(label);
    return duration;
  }
  
  static measure<T>(label: string, fn: () => T): T {
    this.start(label);
    try {
      return fn();
    } finally {
      this.end(label);
    }
  }
}

// 사용 예제
const result = Profiler.measure('CPU 실행', () => {
  return cpu.executeProgram(program);
});
```

### 메모리 덤프 도구

```typescript
function dumpMemory(
  memory: MemoryManager, 
  start: number, 
  length: number
): string {
  let output = `메모리 덤프 (0x${start.toString(16)} - 0x${(start + length).toString(16)}):\n`;
  
  for (let i = 0; i < length; i += 16) {
    const addr = start + i;
    let line = `0x${addr.toString(16).padStart(4, '0')}: `;
    
    // 16바이트 헥사 표시
    for (let j = 0; j < 16 && i + j < length; j++) {
      const value = memory.read(addr + j);
      line += `${value.toString(16).padStart(2, '0')} `;
    }
    
    // ASCII 표시
    line += ' |';
    for (let j = 0; j < 16 && i + j < length; j++) {
      const value = memory.read(addr + j);
      const char = value >= 32 && value <= 126 ? String.fromCharCode(value) : '.';
      line += char;
    }
    line += '|';
    
    output += line + '\n';
  }
  
  return output;
}
```

## ⚡ 성능 최적화

### CPU 최적화 기법

```typescript
// 명령어 실행 최적화
class OptimizedCPU extends CPU6502 {
  private instructionCache = new Map<number, CPUInstruction>();
  
  protected executeInstruction(opcode: number): void {
    // 캐시된 명령어 사용
    let instruction = this.instructionCache.get(opcode);
    
    if (!instruction) {
      instruction = this.opcodes[opcode];
      this.instructionCache.set(opcode, instruction);
    }
    
    instruction.execute(this);
  }
}

// 메모리 접근 최적화
class FastMemory implements MemoryManager {
  private cache = new Map<number, number>();
  
  read(address: number): number {
    // 페이지 제로는 캐시 사용
    if (address < 256) {
      let value = this.cache.get(address);
      if (value === undefined) {
        value = this.memory[address];
        this.cache.set(address, value);
      }
      return value;
    }
    
    return this.memory[address];
  }
}
```

### BASIC 파서 최적화

```typescript
// 토큰 캐싱
class TokenCache {
  private cache = new Map<string, Token[]>();
  
  tokenize(line: string): Token[] {
    let tokens = this.cache.get(line);
    
    if (!tokens) {
      tokens = this.parser.tokenize(line);
      this.cache.set(line, tokens);
    }
    
    return tokens;
  }
}

// 표현식 컴파일
class ExpressionCompiler {
  compile(expression: string): CompiledExpression {
    // BASIC 표현식을 JavaScript 함수로 컴파일
    const jsCode = this.translateToJS(expression);
    return new Function('vars', `return ${jsCode}`) as CompiledExpression;
  }
}
```

## 🐛 트러블슈팅

### 일반적인 문제들

#### 1. TypeScript 컴파일 에러

```bash
# 문제: 타입 에러
error TS2322: Type 'number' is not assignable to type 'string'

# 해결: 타입 가드 사용
function isString(value: unknown): value is string {
  return typeof value === 'string';
}

if (isString(userInput)) {
  // 여기서 userInput은 string으로 타입 narrowing
  console.log(userInput.toUpperCase());
}
```

#### 2. 메모리 누수

```typescript
// 문제: 이벤트 리스너 정리 안됨
class Component {
  constructor() {
    window.addEventListener('resize', this.handleResize);
  }
  
  // 해결: cleanup 메서드 추가
  destroy(): void {
    window.removeEventListener('resize', this.handleResize);
  }
  
  private handleResize = (): void => {
    // 핸들러 로직
  }
}
```

#### 3. 성능 문제

```typescript
// 문제: 매 프레임마다 객체 생성
function render(): void {
  const config = { width: 800, height: 600 }; // ❌ 매번 생성
  drawScreen(config);
}

// 해결: 객체 재사용
const SCREEN_CONFIG = { width: 800, height: 600 }; // ✅ 상수로 선언

function render(): void {
  drawScreen(SCREEN_CONFIG);
}
```

### 디버깅 체크리스트

- [ ] 콘솔에서 TypeScript 에러 확인
- [ ] 브라우저 개발자 도구에서 JavaScript 에러 확인  
- [ ] 메모리 사용량 모니터링
- [ ] 성능 프로파일링 실행
- [ ] 단위 테스트 실행
- [ ] 통합 테스트 실행

### 로그 레벨 설정

```typescript
enum LogLevel {
  ERROR = 0,
  WARN = 1,
  INFO = 2,
  DEBUG = 3
}

class Logger {
  private static level = LogLevel.INFO;
  
  static setLevel(level: LogLevel): void {
    this.level = level;
  }
  
  static debug(message: string): void {
    if (this.level >= LogLevel.DEBUG) {
      console.debug(`[DEBUG] ${message}`);
    }
  }
  
  static info(message: string): void {
    if (this.level >= LogLevel.INFO) {
      console.info(`[INFO] ${message}`);
    }
  }
}

// 환경별 로그 레벨 설정
if (process.env.NODE_ENV === 'development') {
  Logger.setLevel(LogLevel.DEBUG);
} else {
  Logger.setLevel(LogLevel.WARN);
}
```

## 🧪 테스트 작성 가이드

### 단위 테스트 패턴

```typescript
describe('CPU6502', () => {
  let cpu: CPU6502;
  let memory: MemoryManager;
  
  beforeEach(() => {
    memory = new MemoryManager();
    cpu = new CPU6502(memory);
    cpu.reset();
  });
  
  describe('LDA 명령어', () => {
    it('즉시 주소 지정 모드로 누산기에 값을 로드해야 함', () => {
      // Given: LDA #$42 명령어 설정
      memory.write(0x0000, 0xA9); // LDA 즉시 주소 지정
      memory.write(0x0001, 0x42); // 값 0x42
      
      // When: 명령어 실행
      cpu.step();
      
      // Then: 누산기에 0x42가 로드되어야 함
      expect(cpu.registers.A).toBe(0x42);
      expect(cpu.registers.PC).toBe(0x0002);
      expect(cpu.getFlag(CPUFlag.ZERO)).toBe(false);
      expect(cpu.getFlag(CPUFlag.NEGATIVE)).toBe(false);
    });
  });
});
```

### 통합 테스트 패턴

```typescript
describe('BASIC 인터프리터 통합 테스트', () => {
  let system: Basic6502System;
  
  beforeEach(() => {
    system = new Basic6502System();
  });
  
  it('간단한 PRINT 프로그램을 실행할 수 있어야 함', async () => {
    // Given
    const program = [
      '10 PRINT "HELLO WORLD"',
      '20 END'
    ];
    
    // When
    system.loadProgram(program);
    const output = await system.run();
    
    // Then
    expect(output).toContain('HELLO WORLD');
  });
});
```

## 🎵 오디오 개발 가이드

### 오디오 엔진 아키텍처

```typescript
// 오디오 엔진 구조
AudioEngine
├── MMLParser          // MML 문자열 파싱
├── NoteGenerator      // 음표 생성기
├── ChannelManager     // 3채널 관리
├── WaveformGenerator  // 파형 생성 (Sine, Square, Sawtooth, Triangle)
└── EffectsProcessor   // 이펙트 처리 (Fade, ADSR)
```

### MML 파서 구현

```typescript
class MMLParser {
  parse(mml: string): Token[] {
    const tokens: Token[] = [];
    let i = 0;

    while (i < mml.length) {
      const char = mml[i];

      // 음표 파싱 (A-G)
      if (/[A-G]/i.test(char)) {
        const note = this.parseNote(mml, i);
        tokens.push(note);
        i += note.length;
      }
      // 볼륨 파싱 (V0-V15)
      else if (char === 'V') {
        const volume = this.parseVolume(mml, i);
        tokens.push(volume);
        i += volume.length;
      }
      // 파형 파싱 (W0-W3)
      else if (char === 'W') {
        const waveform = this.parseWaveform(mml, i);
        tokens.push(waveform);
        i += waveform.length;
      }
      // 반복 파싱 ([...]n)
      else if (char === '[') {
        const repeat = this.parseRepeat(mml, i);
        tokens.push(repeat);
        i += repeat.length;
      }
      // 타이 파싱 (&)
      else if (char === '&') {
        tokens.push({ type: 'tie' });
        i++;
      }
      else {
        i++;
      }
    }

    return tokens;
  }
}
```

### 채널 관리

```typescript
class ChannelManager {
  private channels: AudioChannel[] = [];

  constructor(channelCount: number = 3) {
    for (let i = 0; i < channelCount; i++) {
      this.channels.push(new AudioChannel(i));
    }
  }

  async playOnChannel(channelId: number, mml: string): Promise<void> {
    const channel = this.channels[channelId];
    if (!channel) {
      throw new Error(`Invalid channel: ${channelId}`);
    }

    const tokens = this.parser.parse(mml);
    await channel.play(tokens);
  }

  stopChannel(channelId: number): void {
    this.channels[channelId]?.stop();
  }

  stopAll(): void {
    this.channels.forEach(channel => channel.stop());
  }
}
```

### 테스트 예제

```typescript
describe('MML Parser', () => {
  let parser: MMLParser;

  beforeEach(() => {
    parser = new MMLParser();
  });

  test('should parse volume commands', () => {
    const tokens = parser.parse('V15 C V0 D');
    expect(tokens[0]).toEqual({ type: 'volume', value: 15 });
    expect(tokens[2]).toEqual({ type: 'volume', value: 0 });
  });

  test('should parse repeat patterns', () => {
    const tokens = parser.parse('[CDEFG]4');
    const expanded = parser.expandRepeats(tokens);
    expect(expanded.length).toBe(20); // 5 notes × 4 repeats
  });
});
```

## 📱 모바일 개발 가이드

### 가상 키보드 구현

```typescript
class VirtualKeyboard {
  private element: HTMLElement;
  private layouts: Record<string, KeyLayout> = {
    default: this.createQWERTYLayout(),
    basic: this.createBASICLayout(),
    numeric: this.createNumericLayout(),
    symbols: this.createSymbolsLayout()
  };

  show(): void {
    this.element.classList.add('visible');
    this.applyLayout(this.currentLayout);
  }

  setLayout(layout: KeyboardLayout): void {
    this.currentLayout = layout;
    this.renderKeys(this.layouts[layout]);
  }

  private createBASICLayout(): KeyLayout {
    return {
      rows: [
        ['PRINT', 'FOR', 'IF', 'GOTO', 'GOSUB'],
        ['LET', 'DIM', 'REM', 'INPUT', 'END'],
        ['THEN', 'NEXT', 'RETURN', 'DATA', 'READ']
      ]
    };
  }
}
```

### 터치 제스처 처리

```typescript
class GestureHandler {
  private touchStart: Touch | null = null;

  handleTouchStart(event: TouchEvent): void {
    if (event.touches.length === 1) {
      this.touchStart = event.touches[0];
    }
  }

  handleTouchEnd(event: TouchEvent): void {
    if (!this.touchStart) return;

    const touchEnd = event.changedTouches[0];
    const dx = touchEnd.clientX - this.touchStart.clientX;
    const dy = touchEnd.clientY - this.touchStart.clientY;

    // 스와이프 감지
    if (Math.abs(dx) > 50) {
      const direction = dx > 0 ? 'right' : 'left';
      this.emit('swipe', { direction, distance: Math.abs(dx) });
    }

    this.touchStart = null;
  }
}
```

### 성능 모니터링

```typescript
class MobilePerformanceMonitor {
  private metrics: PerformanceMetrics = {
    fps: 0,
    memory: 0,
    battery: 1,
    network: 'unknown',
    touchLatency: 0,
    renderTime: 0
  };

  startMonitoring(): void {
    // FPS 측정
    let lastTime = performance.now();
    let frameCount = 0;

    const measureFPS = () => {
      frameCount++;
      const currentTime = performance.now();
      const elapsed = currentTime - lastTime;

      if (elapsed >= 1000) {
        this.metrics.fps = frameCount;
        frameCount = 0;
        lastTime = currentTime;
      }

      requestAnimationFrame(measureFPS);
    };

    requestAnimationFrame(measureFPS);

    // 배터리 레벨 측정
    if ('getBattery' in navigator) {
      (navigator as any).getBattery().then((battery: any) => {
        this.metrics.battery = battery.level;
        battery.addEventListener('levelchange', () => {
          this.metrics.battery = battery.level;
        });
      });
    }
  }
}
```

## 🧪 테스트 개발 가이드

### 테스트 구조

```
tests/
├── unit/              # 단위 테스트
│   ├── cpu/          # CPU 테스트
│   ├── memory/       # 메모리 테스트
│   └── basic/        # BASIC 테스트
├── integration/       # 통합 테스트
│   ├── system/       # 시스템 통합
│   └── modules/      # 모듈 간 통합
└── e2e/              # E2E 테스트
    ├── scenarios/    # 사용자 시나리오
    └── workflows/    # 워크플로우
```

### 모킹 유틸리티

```typescript
// test-utils.ts
export class MockAudioContext {
  currentTime = 0;
  sampleRate = 44100;

  createOscillator() {
    return new MockOscillator();
  }

  createGain() {
    return new MockGainNode();
  }
}

export function setupAudioMock(): void {
  (global as any).AudioContext = MockAudioContext;
  (global as any).webkitAudioContext = MockAudioContext;
}

export function setupCanvasMock(): void {
  HTMLCanvasElement.prototype.getContext = function() {
    return new MockCanvasContext();
  };
}
```

### 테스트 커버리지 목표

```typescript
// jest.config.js 또는 vitest.config.ts
export default {
  coverageThreshold: {
    global: {
      statements: 90,
      branches: 85,
      functions: 90,
      lines: 90
    },
    './src/audio/': {
      statements: 95,
      branches: 90,
      functions: 95,
      lines: 95
    },
    './src/graphics/': {
      statements: 100,
      branches: 95,
      functions: 100,
      lines: 100
    }
  }
};
```

### 성능 테스트

```typescript
describe('Performance Tests', () => {
  test('should render graphics at 60 FPS', () => {
    const graphics = new GraphicsEngine();
    const startTime = performance.now();
    let frameCount = 0;

    // 1초간 렌더링
    while (performance.now() - startTime < 1000) {
      graphics.render();
      frameCount++;
    }

    expect(frameCount).toBeGreaterThanOrEqual(60);
  });

  test('should parse MML within performance budget', () => {
    const parser = new MMLParser();
    const mml = 'CDEFGAB'.repeat(100); // 700 notes

    const startTime = performance.now();
    const tokens = parser.parse(mml);
    const parseTime = performance.now() - startTime;

    expect(parseTime).toBeLessThan(50); // < 50ms
    expect(tokens.length).toBe(700);
  });
});
```

## 📚 추가 자료

### 관련 문서
- [테스트 가이드](./테스트가이드.md) - 종합적인 테스트 작성 및 실행 가이드
- [API 문서](./API문서.md) - 전체 API 레퍼런스
- [사용자 가이드](./사용자가이드.md) - BASIC 언어 사용법
- [릴리스 노트](../RELEASE_NOTES.md) - Version 2.0.0 변경사항

### 외부 참고 자료
- [6502 CPU Reference](http://www.6502.org/tutorials/)
- [Microsoft BASIC 1.1 Specification](https://archive.org/details/microsoft-basic-1.1)
- [MML (Music Macro Language)](https://en.wikipedia.org/wiki/Music_Macro_Language)
- [Web Audio API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API)

---

**Version**: 2.0.0
**Last Updated**: 2025-10-04

이 가이드를 통해 6502 BASIC JavaScript 에뮬레이터 개발에 효율적으로 참여할 수 있습니다. 추가 질문이나 개선 사항이 있다면 언제든지 문의해 주세요!