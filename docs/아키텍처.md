# ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜ ë¬¸ì„œ

> 6502 BASIC JavaScript ì—ë®¬ë ˆì´í„°ì˜ ì „ì²´ì ì¸ ì‹œìŠ¤í…œ ì„¤ê³„ ë° êµ¬ì¡°

## ğŸ“‹ ëª©ì°¨

1. [ì•„í‚¤í…ì²˜ ê°œìš”](#ì•„í‚¤í…ì²˜-ê°œìš”)
2. [ê³„ì¸µë³„ êµ¬ì¡°](#ê³„ì¸µë³„-êµ¬ì¡°)
3. [ëª¨ë“ˆ ìƒì„¸ ì„¤ê³„](#ëª¨ë“ˆ-ìƒì„¸-ì„¤ê³„)
4. [ë°ì´í„° íë¦„](#ë°ì´í„°-íë¦„)
5. [ìƒíƒœ ê´€ë¦¬](#ìƒíƒœ-ê´€ë¦¬)
6. [ì„±ëŠ¥ ê³ ë ¤ì‚¬í•­](#ì„±ëŠ¥-ê³ ë ¤ì‚¬í•­)
7. [í™•ì¥ì„± ì„¤ê³„](#í™•ì¥ì„±-ì„¤ê³„)
8. [ë³´ì•ˆ ê³ ë ¤ì‚¬í•­](#ë³´ì•ˆ-ê³ ë ¤ì‚¬í•­)

## ğŸ—ï¸ ì•„í‚¤í…ì²˜ ê°œìš”

### ì „ì²´ ì‹œìŠ¤í…œ êµ¬ì¡°

```mermaid
graph TB
    subgraph "ì›¹ ë¸Œë¼ìš°ì € í™˜ê²½"
        UI[ì‚¬ìš©ì ì¸í„°í˜ì´ìŠ¤ ë ˆì´ì–´]
        BASIC[BASIC ì¸í„°í”„ë¦¬í„° ë ˆì´ì–´]
        CPU[6502 CPU ì—ë®¬ë ˆì´ì…˜ ë ˆì´ì–´]
        MEMORY[ë©”ëª¨ë¦¬ ê´€ë¦¬ ë ˆì´ì–´]
        IO[I/O ì‹œìŠ¤í…œ ë ˆì´ì–´]
        MATH[ìˆ˜í•™ ì²˜ë¦¬ ë ˆì´ì–´]
    end
    
    UI --> BASIC
    BASIC --> CPU
    BASIC --> MEMORY
    CPU --> MEMORY
    CPU --> MATH
    BASIC --> IO
    UI --> IO
    
    subgraph "ì™¸ë¶€ ì €ì¥ì†Œ"
        LOCAL[ë¡œì»¬ ìŠ¤í† ë¦¬ì§€]
        SESSION[ì„¸ì…˜ ìŠ¤í† ë¦¬ì§€]
    end
    
    IO --> LOCAL
    IO --> SESSION
```

### í•µì‹¬ ì„¤ê³„ ì›ì¹™

1. **ëª¨ë“ˆì„±**: ê° ì»´í¬ë„ŒíŠ¸ëŠ” ë…ë¦½ì ì´ê³  êµì²´ ê°€ëŠ¥
2. **íƒ€ì… ì•ˆì „ì„±**: TypeScriptë¥¼ í†µí•œ ì»´íŒŒì¼ íƒ€ì„ ì˜¤ë¥˜ ë°©ì§€
3. **ì„±ëŠ¥**: ë¸Œë¼ìš°ì € í™˜ê²½ì—ì„œ ì‹¤ì‹œê°„ ì‹¤í–‰ ê°€ëŠ¥í•œ ìµœì í™”
4. **í™•ì¥ì„±**: ìƒˆë¡œìš´ ê¸°ëŠ¥ê³¼ í”Œë«í¼ ì§€ì› ìš©ì´
5. **í…ŒìŠ¤íŠ¸ ê°€ëŠ¥ì„±**: ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ì™€ í†µí•© í…ŒìŠ¤íŠ¸ ì§€ì›
6. **ì‚¬ìš©ì ê²½í—˜**: ì§ê´€ì ì´ê³  ë°˜ì‘ì„± ì¢‹ì€ ì¸í„°í˜ì´ìŠ¤

## ğŸ›ï¸ ê³„ì¸µë³„ êµ¬ì¡°

### 1. í”„ë ˆì  í…Œì´ì…˜ ë ˆì´ì–´ (UI)

**ì±…ì„**: ì‚¬ìš©ì ìƒí˜¸ì‘ìš© ë° í™”ë©´ í‘œì‹œ

```typescript
interface PresentationLayer {
  components: {
    Terminal: TerminalComponent;
    Editor: EditorComponent;  
    Debugger: DebuggerComponent;
    FileManager: FileManagerComponent;
  };
  
  events: EventSystem;
  state: UIState;
}
```

**ì£¼ìš” ì»´í¬ë„ŒíŠ¸**:
- **í„°ë¯¸ë„**: BASIC ëª…ë ¹ ì‹¤í–‰ ë° ì¶œë ¥ í‘œì‹œ
- **ì—ë””í„°**: í”„ë¡œê·¸ë¨ ì‘ì„± ë° í¸ì§‘
- **ë””ë²„ê±°**: ì‹¤í–‰ ì¶”ì  ë° ë³€ìˆ˜ ëª¨ë‹ˆí„°ë§
- **íŒŒì¼ ê´€ë¦¬ì**: í”„ë¡œê·¸ë¨ ì €ì¥/ë¡œë“œ

### 2. ì• í”Œë¦¬ì¼€ì´ì…˜ ë ˆì´ì–´ (BASIC ì¸í„°í”„ë¦¬í„°)

**ì±…ì„**: BASIC ì–¸ì–´ ì²˜ë¦¬ ë° í”„ë¡œê·¸ë¨ ì‹¤í–‰ ì œì–´

```typescript
interface ApplicationLayer {
  parser: BasicParser;
  interpreter: BasicInterpreter;
  runtime: RuntimeEnvironment;
  variables: VariableManager;
  functions: FunctionLibrary;
}
```

**í•µì‹¬ ê¸°ëŠ¥**:
- **íŒŒì„œ**: BASIC ì†ŒìŠ¤ì½”ë“œ â†’ AST (ì¶”ìƒ êµ¬ë¬¸ íŠ¸ë¦¬)
- **ì¸í„°í”„ë¦¬í„°**: AST ì‹¤í–‰ ì—”ì§„
- **ëŸ°íƒ€ì„**: ì‹¤í–‰ ì»¨í…ìŠ¤íŠ¸ ê´€ë¦¬
- **ë³€ìˆ˜ ê´€ë¦¬**: ë©”ëª¨ë¦¬ í• ë‹¹ ë° ê°€ë¹„ì§€ ì»¬ë ‰ì…˜

### 3. ì—ë®¬ë ˆì´ì…˜ ë ˆì´ì–´ (6502 CPU)

**ì±…ì„**: 6502 ë§ˆì´í¬ë¡œí”„ë¡œì„¸ì„œ ì™„ì „ ì—ë®¬ë ˆì´ì…˜

```typescript
interface EmulationLayer {
  cpu: CPU6502;
  instructions: InstructionSet;
  addressingModes: AddressingModeManager;
  interrupts: InterruptController;
}
```

**í•µì‹¬ ì»´í¬ë„ŒíŠ¸**:
- **CPU ì½”ì–´**: ë ˆì§€ìŠ¤í„°, í”Œë˜ê·¸, ì‹¤í–‰ íŒŒì´í”„ë¼ì¸
- **ëª…ë ¹ì–´ ì„¸íŠ¸**: 151ê°œ 6502 ëª…ë ¹ì–´ êµ¬í˜„
- **ì£¼ì†Œ ì§€ì •**: 13ê°€ì§€ ì£¼ì†Œ ì§€ì • ëª¨ë“œ
- **ì¸í„°ëŸ½íŠ¸**: IRQ, NMI, BRK ì²˜ë¦¬

### 4. ì¸í”„ë¼ìŠ¤íŠ¸ëŸ­ì²˜ ë ˆì´ì–´

**ì±…ì„**: í•˜ìœ„ ìˆ˜ì¤€ ì‹œìŠ¤í…œ ì„œë¹„ìŠ¤

```typescript
interface InfrastructureLayer {
  memory: MemoryManager;
  io: IOSystem;
  storage: StorageManager;
  events: EventEmitter;
  performance: PerformanceMonitor;
}
```

## ğŸ”§ ëª¨ë“ˆ ìƒì„¸ ì„¤ê³„

### CPU ì—ë®¬ë ˆì´í„° ëª¨ë“ˆ

#### ì•„í‚¤í…ì²˜ íŒ¨í„´: Command Pattern + Strategy Pattern

```typescript
// ëª…ë ¹ì–´ ì¸í„°í˜ì´ìŠ¤ (Command Pattern)
interface CPUInstruction {
  readonly opcode: number;
  readonly mnemonic: string;
  readonly cycles: number;
  readonly addressingMode: AddressingMode;
  
  execute(cpu: CPU6502): void;
}

// ì£¼ì†Œ ì§€ì • ì „ëµ (Strategy Pattern)
interface AddressingStrategy {
  getOperandAddress(cpu: CPU6502): number;
  getOperandValue(cpu: CPU6502): number;
}

// CPU ì½”ì–´ í´ë˜ìŠ¤
class CPU6502 {
  private readonly registers: CPURegisters;
  private readonly memory: MemoryManager;
  private readonly instructions: Map<number, CPUInstruction>;
  private readonly addressingModes: Map<AddressingMode, AddressingStrategy>;
  
  public step(): number {
    const opcode = this.fetchByte();
    const instruction = this.instructions.get(opcode);
    
    if (!instruction) {
      throw new CPUError(`Unknown opcode: 0x${opcode.toString(16)}`);
    }
    
    instruction.execute(this);
    return instruction.cycles;
  }
}
```

#### ë ˆì§€ìŠ¤í„° ê´€ë¦¬

```typescript
class CPURegisters {
  private _A: number = 0;    // ëˆ„ì‚°ê¸°
  private _X: number = 0;    // X ì¸ë±ìŠ¤
  private _Y: number = 0;    // Y ì¸ë±ìŠ¤  
  private _SP: number = 0xFF; // ìŠ¤íƒ í¬ì¸í„°
  private _PC: number = 0;    // í”„ë¡œê·¸ë¨ ì¹´ìš´í„°
  private _P: number = 0x20;  // ìƒíƒœ ë ˆì§€ìŠ¤í„°
  
  // getter/setter with validation
  public get A(): number { return this._A; }
  public set A(value: number) { 
    this._A = this.validateByte(value);
    this.updateZeroNegativeFlags(this._A);
  }
  
  private validateByte(value: number): number {
    return value & 0xFF; // 0-255 ë²”ìœ„ë¡œ ì œí•œ
  }
  
  private updateZeroNegativeFlags(value: number): void {
    this.setFlag(CPUFlag.ZERO, value === 0);
    this.setFlag(CPUFlag.NEGATIVE, (value & 0x80) !== 0);
  }
}
```

### BASIC ì¸í„°í”„ë¦¬í„° ëª¨ë“ˆ

#### ì•„í‚¤í…ì²˜ íŒ¨í„´: Interpreter Pattern + Visitor Pattern

```typescript
// AST ë…¸ë“œ ì¸í„°í˜ì´ìŠ¤
interface ASTNode {
  accept<T>(visitor: ASTVisitor<T>): T;
}

// ë¬¸ì¥ ë…¸ë“œ
class PrintStatement implements ASTNode {
  constructor(public readonly expressions: Expression[]) {}
  
  accept<T>(visitor: ASTVisitor<T>): T {
    return visitor.visitPrintStatement(this);
  }
}

// í‘œí˜„ì‹ ë…¸ë“œ
class BinaryExpression implements ASTNode {
  constructor(
    public readonly left: Expression,
    public readonly operator: BinaryOperator,
    public readonly right: Expression
  ) {}
  
  accept<T>(visitor: ASTVisitor<T>): T {
    return visitor.visitBinaryExpression(this);
  }
}

// ë°©ë¬¸ì ì¸í„°í˜ì´ìŠ¤ (Visitor Pattern)
interface ASTVisitor<T> {
  visitPrintStatement(node: PrintStatement): T;
  visitBinaryExpression(node: BinaryExpression): T;
  visitVariableExpression(node: VariableExpression): T;
  visitLiteralExpression(node: LiteralExpression): T;
}

// ì¸í„°í”„ë¦¬í„° ë°©ë¬¸ì
class InterpreterVisitor implements ASTVisitor<BasicValue> {
  constructor(private readonly environment: Environment) {}
  
  visitPrintStatement(node: PrintStatement): BasicValue {
    const values = node.expressions.map(expr => expr.accept(this));
    const output = values.map(v => this.stringify(v)).join(' ');
    this.environment.output(output);
    return null;
  }
  
  visitBinaryExpression(node: BinaryExpression): BasicValue {
    const left = node.left.accept(this);
    const right = node.right.accept(this);
    return this.evaluateBinaryOperation(left, node.operator, right);
  }
}
```

#### íŒŒì„œ ì„¤ê³„ (Recursive Descent Parser)

```typescript
class BasicParser {
  private tokens: Token[];
  private current: number = 0;
  
  public parse(source: string): Program {
    this.tokens = this.tokenize(source);
    this.current = 0;
    
    const lines: ProgramLine[] = [];
    while (!this.isAtEnd()) {
      lines.push(this.parseLine());
    }
    
    return new Program(lines);
  }
  
  private parseLine(): ProgramLine {
    const lineNumber = this.consumeNumber();
    const statement = this.parseStatement();
    return new ProgramLine(lineNumber, statement);
  }
  
  private parseStatement(): Statement {
    if (this.match('PRINT')) return this.parsePrintStatement();
    if (this.match('LET')) return this.parseLetStatement();
    if (this.match('IF')) return this.parseIfStatement();
    if (this.match('FOR')) return this.parseForStatement();
    if (this.match('GOTO')) return this.parseGotoStatement();
    
    throw new ParseError('Unexpected token: ' + this.peek().lexeme);
  }
  
  private parsePrintStatement(): PrintStatement {
    const expressions: Expression[] = [];
    
    do {
      expressions.push(this.parseExpression());
    } while (this.match(',', ';'));
    
    return new PrintStatement(expressions);
  }
  
  private parseExpression(): Expression {
    return this.parseLogicalOr();
  }
  
  private parseLogicalOr(): Expression {
    let expr = this.parseLogicalAnd();
    
    while (this.match('OR')) {
      const operator = this.previous();
      const right = this.parseLogicalAnd();
      expr = new BinaryExpression(expr, operator.type, right);
    }
    
    return expr;
  }
}
```

### ë©”ëª¨ë¦¬ ê´€ë¦¬ ëª¨ë“ˆ

#### ì•„í‚¤í…ì²˜ íŒ¨í„´: Strategy Pattern + Observer Pattern

```typescript
// ë©”ëª¨ë¦¬ ì „ëµ ì¸í„°í˜ì´ìŠ¤
interface MemoryStrategy {
  read(address: number): number;
  write(address: number, value: number): void;
}

// ê¸°ë³¸ RAM ì „ëµ
class RAMStrategy implements MemoryStrategy {
  private readonly data: Uint8Array;
  
  constructor(size: number) {
    this.data = new Uint8Array(size);
  }
  
  read(address: number): number {
    return this.data[address];
  }
  
  write(address: number, value: number): void {
    this.data[address] = value & 0xFF;
  }
}

// ROM ì „ëµ (ì½ê¸° ì „ìš©)
class ROMStrategy implements MemoryStrategy {
  private readonly data: Uint8Array;
  
  constructor(data: Uint8Array) {
    this.data = new Uint8Array(data);
  }
  
  read(address: number): number {
    return this.data[address];
  }
  
  write(address: number, value: number): void {
    // ROMì€ ì“°ê¸° ë¶ˆê°€ - ë¬´ì‹œí•˜ê±°ë‚˜ ì—ëŸ¬ ë°œìƒ
    console.warn(`Attempt to write to ROM address 0x${address.toString(16)}`);
  }
}

// ë©”ëª¨ë¦¬ ê´€ë¦¬ì (Observer Pattern)
class MemoryManager extends EventEmitter<MemoryEvents> {
  private readonly banks: Map<number, MemoryStrategy>;
  private readonly watchers: Set<MemoryWatcher>;
  
  constructor() {
    super();
    this.banks = new Map();
    this.watchers = new Set();
    this.initializeDefaultBanks();
  }
  
  public read(address: number): number {
    const bank = this.getBank(address);
    const value = bank.read(address);
    
    // ë©”ëª¨ë¦¬ ì½ê¸° ì´ë²¤íŠ¸ ë°œìƒ
    this.emit('read', { address, value });
    
    // ì›Œì²˜ì—ê²Œ ì•Œë¦¼
    this.notifyWatchers('read', address, value);
    
    return value;
  }
  
  public write(address: number, value: number): void {
    const bank = this.getBank(address);
    bank.write(address, value);
    
    // ë©”ëª¨ë¦¬ ì“°ê¸° ì´ë²¤íŠ¸ ë°œìƒ
    this.emit('write', { address, value });
    
    // ì›Œì²˜ì—ê²Œ ì•Œë¦¼
    this.notifyWatchers('write', address, value);
  }
  
  private getBank(address: number): MemoryStrategy {
    const bankId = Math.floor(address / 0x1000); // 4KB ë±…í¬
    return this.banks.get(bankId) || this.banks.get(0)!;
  }
}
```

#### ê°€ë¹„ì§€ ì»¬ë ‰ì…˜ (ë¬¸ìì—´ ë©”ëª¨ë¦¬)

```typescript
class StringGarbageCollector {
  private readonly heap: StringHeap;
  private readonly roots: Set<StringReference>;
  
  constructor(heap: StringHeap) {
    this.heap = heap;
    this.roots = new Set();
  }
  
  public collect(): GCStats {
    const startTime = performance.now();
    const initialMemory = this.heap.getUsedMemory();
    
    // Mark phase: ë„ë‹¬ ê°€ëŠ¥í•œ ë¬¸ìì—´ ë§ˆí‚¹
    const marked = this.mark();
    
    // Sweep phase: ë§ˆí‚¹ë˜ì§€ ì•Šì€ ë¬¸ìì—´ í•´ì œ
    const freed = this.sweep(marked);
    
    // Compact phase: ë©”ëª¨ë¦¬ ì••ì¶• (ì„ íƒì )
    if (this.shouldCompact()) {
      this.compact();
    }
    
    return {
      duration: performance.now() - startTime,
      freedMemory: freed,
      totalMemory: this.heap.getTotalMemory(),
      usedMemory: this.heap.getUsedMemory()
    };
  }
  
  private mark(): Set<StringReference> {
    const marked = new Set<StringReference>();
    const stack: StringReference[] = Array.from(this.roots);
    
    while (stack.length > 0) {
      const ref = stack.pop()!;
      if (marked.has(ref)) continue;
      
      marked.add(ref);
      
      // ì°¸ì¡°í•˜ëŠ” ë‹¤ë¥¸ ë¬¸ìì—´ë“¤ì„ ìŠ¤íƒì— ì¶”ê°€
      const references = this.heap.getReferences(ref);
      stack.push(...references);
    }
    
    return marked;
  }
  
  private sweep(marked: Set<StringReference>): number {
    let freedMemory = 0;
    
    for (const ref of this.heap.getAllReferences()) {
      if (!marked.has(ref)) {
        freedMemory += this.heap.getSize(ref);
        this.heap.free(ref);
      }
    }
    
    return freedMemory;
  }
}
```

### I/O ì‹œìŠ¤í…œ ëª¨ë“ˆ

#### ì•„í‚¤í…ì²˜ íŒ¨í„´: Command Pattern + Chain of Responsibility

```typescript
// I/O ëª…ë ¹ ì¸í„°í˜ì´ìŠ¤
interface IOCommand {
  execute(): Promise<IOResult>;
  canUndo(): boolean;
  undo(): Promise<void>;
}

// íŒŒì¼ ë¡œë“œ ëª…ë ¹
class LoadFileCommand implements IOCommand {
  constructor(
    private readonly filename: string,
    private readonly storage: StorageManager
  ) {}
  
  async execute(): Promise<IOResult> {
    try {
      const content = await this.storage.load(this.filename);
      return { success: true, data: content };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }
  
  canUndo(): boolean {
    return false; // íŒŒì¼ ë¡œë“œëŠ” ì–¸ë‘ ë¶ˆê°€
  }
  
  async undo(): Promise<void> {
    throw new Error('Cannot undo file load operation');
  }
}

// I/O í•¸ë“¤ëŸ¬ ì²´ì¸
abstract class IOHandler {
  protected next?: IOHandler;
  
  public setNext(handler: IOHandler): IOHandler {
    this.next = handler;
    return handler;
  }
  
  public async handle(request: IORequest): Promise<IOResult> {
    if (this.canHandle(request)) {
      return this.process(request);
    } else if (this.next) {
      return this.next.handle(request);
    } else {
      throw new Error(`No handler found for request type: ${request.type}`);
    }
  }
  
  protected abstract canHandle(request: IORequest): boolean;
  protected abstract process(request: IORequest): Promise<IOResult>;
}

// ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ í•¸ë“¤ëŸ¬
class LocalStorageHandler extends IOHandler {
  protected canHandle(request: IORequest): boolean {
    return request.type === 'localStorage';
  }
  
  protected async process(request: IORequest): Promise<IOResult> {
    switch (request.operation) {
      case 'save':
        localStorage.setItem(request.key, request.data);
        return { success: true };
        
      case 'load':
        const data = localStorage.getItem(request.key);
        return { success: true, data };
        
      case 'delete':
        localStorage.removeItem(request.key);
        return { success: true };
        
      default:
        return { success: false, error: 'Unknown operation' };
    }
  }
}
```

## ğŸ“Š ë°ì´í„° íë¦„

### ì „ì²´ ë°ì´í„° íë¦„ ë‹¤ì´ì–´ê·¸ë¨

```mermaid
sequenceDiagram
    participant User
    participant UI
    participant BASIC
    participant CPU
    participant Memory
    participant IO
    
    User->>UI: í”„ë¡œê·¸ë¨ ì…ë ¥
    UI->>BASIC: íŒŒì‹± ìš”ì²­
    BASIC->>BASIC: AST ìƒì„±
    
    User->>UI: RUN ëª…ë ¹
    UI->>BASIC: ì‹¤í–‰ ìš”ì²­
    
    loop í”„ë¡œê·¸ë¨ ì‹¤í–‰
        BASIC->>CPU: ëª…ë ¹ì–´ ì‹¤í–‰ ìš”ì²­
        CPU->>Memory: ë©”ëª¨ë¦¬ ì ‘ê·¼
        Memory-->>CPU: ë°ì´í„° ë°˜í™˜
        CPU-->>BASIC: ì‹¤í–‰ ì™„ë£Œ
        
        alt ì¶œë ¥ ëª…ë ¹
            BASIC->>UI: ì¶œë ¥ ë°ì´í„°
            UI->>User: í™”ë©´ ì¶œë ¥
        end
        
        alt ì…ë ¥ ëª…ë ¹
            BASIC->>UI: ì…ë ¥ ìš”ì²­
            UI->>User: ì…ë ¥ í”„ë¡¬í”„íŠ¸
            User-->>UI: ì‚¬ìš©ì ì…ë ¥
            UI-->>BASIC: ì…ë ¥ ë°ì´í„°
        end
        
        alt íŒŒì¼ I/O
            BASIC->>IO: íŒŒì¼ ì‘ì—… ìš”ì²­
            IO->>IO: ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ ì ‘ê·¼
            IO-->>BASIC: ì‘ì—… ê²°ê³¼
        end
    end
```

### ëª…ë ¹ì–´ ì‹¤í–‰ íë¦„

```typescript
// BASIC ëª…ë ¹ì–´ ì‹¤í–‰ í”Œë¡œìš°
class BasicInterpreter {
  public async executeProgram(program: Program): Promise<ExecutionResult> {
    try {
      // 1. ì´ˆê¸°í™”
      this.runtime.initialize();
      this.variables.clear();
      
      // 2. í”„ë¡œê·¸ë¨ ë¼ì¸ë³„ ì‹¤í–‰
      for (const line of program.lines) {
        await this.executeLine(line);
        
        // 3. ì œì–´ íë¦„ í™•ì¸
        if (this.runtime.shouldStop()) break;
        if (this.runtime.shouldJump()) {
          const targetLine = this.runtime.getJumpTarget();
          this.runtime.setCurrentLine(targetLine);
        }
      }
      
      return { success: true, output: this.runtime.getOutput() };
      
    } catch (error) {
      return { 
        success: false, 
        error: error.message,
        line: this.runtime.getCurrentLine()
      };
    }
  }
  
  private async executeLine(line: ProgramLine): Promise<void> {
    this.runtime.setCurrentLine(line.lineNumber);
    
    // 4. ëª…ë ¹ë¬¸ íƒ€ì…ë³„ ì²˜ë¦¬
    switch (line.statement.type) {
      case 'PRINT':
        await this.executePrint(line.statement as PrintStatement);
        break;
      case 'LET':
        await this.executeLet(line.statement as LetStatement);
        break;
      case 'IF':
        await this.executeIf(line.statement as IfStatement);
        break;
      // ... ë‹¤ë¥¸ ëª…ë ¹ë¬¸ë“¤
    }
  }
}
```

## ğŸ—„ï¸ ìƒíƒœ ê´€ë¦¬

### ìƒíƒœ ê´€ë¦¬ ì•„í‚¤í…ì²˜

```typescript
// ì¤‘ì•™ ìƒíƒœ ì €ì¥ì†Œ (Redux-like íŒ¨í„´)
interface AppState {
  cpu: CPUState;
  basic: BasicState;
  ui: UIState;
  io: IOState;
  debug: DebugState;
}

// ìƒíƒœ ì•¡ì…˜
type AppAction = 
  | CPUAction
  | BasicAction  
  | UIAction
  | IOAction
  | DebugAction;

// ìƒíƒœ ë¦¬ë“€ì„œ
class StateManager {
  private state: AppState;
  private listeners: Set<StateListener>;
  
  constructor(initialState: AppState) {
    this.state = initialState;
    this.listeners = new Set();
  }
  
  public dispatch(action: AppAction): void {
    const newState = this.reduce(this.state, action);
    
    if (newState !== this.state) {
      this.state = newState;
      this.notifyListeners();
    }
  }
  
  public getState(): AppState {
    return this.state;
  }
  
  public subscribe(listener: StateListener): () => void {
    this.listeners.add(listener);
    return () => this.listeners.delete(listener);
  }
  
  private reduce(state: AppState, action: AppAction): AppState {
    switch (action.type) {
      case 'CPU_RESET':
        return {
          ...state,
          cpu: this.cpuReducer(state.cpu, action)
        };
        
      case 'BASIC_PROGRAM_LOAD':
        return {
          ...state,
          basic: this.basicReducer(state.basic, action)
        };
        
      default:
        return state;
    }
  }
}
```

### CPU ìƒíƒœ ê´€ë¦¬

```typescript
interface CPUState {
  registers: {
    A: number;
    X: number;
    Y: number;
    SP: number;
    PC: number;
    P: number;
  };
  flags: {
    carry: boolean;
    zero: boolean;
    interrupt: boolean;
    decimal: boolean;
    break: boolean;
    overflow: boolean;
    negative: boolean;
  };
  cycleCount: number;
  instructionCount: number;
  isRunning: boolean;
  breakpoints: Set<number>;
}

class CPUStateManager {
  public static fromCPU(cpu: CPU6502): CPUState {
    return {
      registers: {
        A: cpu.registers.A,
        X: cpu.registers.X,
        Y: cpu.registers.Y,
        SP: cpu.registers.SP,
        PC: cpu.registers.PC,
        P: cpu.registers.P
      },
      flags: {
        carry: cpu.getFlag(CPUFlag.CARRY),
        zero: cpu.getFlag(CPUFlag.ZERO),
        interrupt: cpu.getFlag(CPUFlag.INTERRUPT),
        decimal: cpu.getFlag(CPUFlag.DECIMAL),
        break: cpu.getFlag(CPUFlag.BREAK),
        overflow: cpu.getFlag(CPUFlag.OVERFLOW),
        negative: cpu.getFlag(CPUFlag.NEGATIVE)
      },
      cycleCount: cpu.getCycleCount(),
      instructionCount: cpu.getInstructionCount(),
      isRunning: cpu.isRunning(),
      breakpoints: new Set(cpu.getBreakpoints())
    };
  }
}
```

## âš¡ ì„±ëŠ¥ ê³ ë ¤ì‚¬í•­

### ìµœì í™” ì „ëµ

#### 1. CPU ì—ë®¬ë ˆì´ì…˜ ìµœì í™”

```typescript
class OptimizedCPU6502 extends CPU6502 {
  // ëª…ë ¹ì–´ ìºì‹±
  private instructionCache = new Map<number, CPUInstruction>();
  
  // ì£¼ì†Œ ê³„ì‚° ìºì‹±
  private addressCache = new Map<string, number>();
  
  // í•«ìŠ¤íŒŸ ê°ì§€
  private hotspots = new Map<number, number>();
  
  public step(): number {
    const pc = this.registers.PC;
    
    // í•«ìŠ¤íŒŸ ì—…ë°ì´íŠ¸
    this.hotspots.set(pc, (this.hotspots.get(pc) || 0) + 1);
    
    // ìºì‹œëœ ëª…ë ¹ì–´ ì‚¬ìš©
    const opcode = this.memory.read(pc);
    let instruction = this.instructionCache.get(opcode);
    
    if (!instruction) {
      instruction = this.opcodes[opcode];
      this.instructionCache.set(opcode, instruction);
    }
    
    // JIT ì»´íŒŒì¼ ê³ ë ¤ (í•«ìŠ¤íŒŸ)
    if (this.hotspots.get(pc)! > 100) {
      this.considerJITCompilation(pc);
    }
    
    instruction.execute(this);
    return instruction.cycles;
  }
  
  private considerJITCompilation(address: number): void {
    // ìì£¼ ì‹¤í–‰ë˜ëŠ” ì½”ë“œ ë¸”ë¡ì„ JavaScriptë¡œ ì»´íŒŒì¼
    // (ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ë” ë³µì¡í•œ ë¶„ì„ í•„ìš”)
    const codeBlock = this.analyzeCodeBlock(address);
    if (codeBlock.isCompilable) {
      this.compileToJS(codeBlock);
    }
  }
}
```

#### 2. ë©”ëª¨ë¦¬ ì ‘ê·¼ ìµœì í™”

```typescript
class OptimizedMemoryManager extends MemoryManager {
  // í˜ì´ì§€ ë‹¨ìœ„ ìºì‹±
  private pageCache = new Map<number, Uint8Array>();
  
  // ë”í‹° í˜ì´ì§€ ì¶”ì 
  private dirtyPages = new Set<number>();
  
  public read(address: number): number {
    const pageNum = address >>> 8; // í˜ì´ì§€ ë²ˆí˜¸ (ìƒìœ„ 8ë¹„íŠ¸)
    const offset = address & 0xFF; // í˜ì´ì§€ ë‚´ ì˜¤í”„ì…‹
    
    let page = this.pageCache.get(pageNum);
    if (!page) {
      page = this.loadPage(pageNum);
      this.pageCache.set(pageNum, page);
    }
    
    return page[offset];
  }
  
  public write(address: number, value: number): void {
    const pageNum = address >>> 8;
    const offset = address & 0xFF;
    
    let page = this.pageCache.get(pageNum);
    if (!page) {
      page = this.loadPage(pageNum);
      this.pageCache.set(pageNum, page);
    }
    
    page[offset] = value & 0xFF;
    this.dirtyPages.add(pageNum);
    
    // ì£¼ê¸°ì ìœ¼ë¡œ ë”í‹° í˜ì´ì§€ í”ŒëŸ¬ì‹œ
    if (this.dirtyPages.size > 16) {
      this.flushDirtyPages();
    }
  }
  
  private loadPage(pageNum: number): Uint8Array {
    const page = new Uint8Array(256);
    const baseAddress = pageNum << 8;
    
    for (let i = 0; i < 256; i++) {
      page[i] = this.memory[baseAddress + i] || 0;
    }
    
    return page;
  }
}
```

#### 3. BASIC ì¸í„°í”„ë¦¬í„° ìµœì í™”

```typescript
class OptimizedBasicInterpreter extends BasicInterpreter {
  // í‘œí˜„ì‹ ìºì‹±
  private expressionCache = new Map<string, CompiledExpression>();
  
  // ë³€ìˆ˜ ì ‘ê·¼ ìµœì í™”
  private variableIndex = new Map<string, number>();
  private variableArray: BasicValue[] = [];
  
  public evaluateExpression(expr: Expression): BasicValue {
    const exprKey = this.getExpressionKey(expr);
    
    // ìºì‹œëœ ì»´íŒŒì¼ëœ í‘œí˜„ì‹ ì‚¬ìš©
    let compiled = this.expressionCache.get(exprKey);
    if (!compiled) {
      compiled = this.compileExpression(expr);
      this.expressionCache.set(exprKey, compiled);
    }
    
    return compiled.evaluate(this.variableArray);
  }
  
  private compileExpression(expr: Expression): CompiledExpression {
    // BASIC í‘œí˜„ì‹ì„ JavaScript í•¨ìˆ˜ë¡œ ì»´íŒŒì¼
    const jsCode = this.generateJS(expr);
    const func = new Function('vars', `return ${jsCode}`);
    
    return {
      evaluate: func,
      dependencies: this.extractDependencies(expr)
    };
  }
  
  public setVariable(name: string, value: BasicValue): void {
    let index = this.variableIndex.get(name);
    if (index === undefined) {
      index = this.variableArray.length;
      this.variableIndex.set(name, index);
      this.variableArray.push(value);
    } else {
      this.variableArray[index] = value;
    }
    
    // ì˜ì¡´ì„±ì´ ìˆëŠ” ìºì‹œëœ í‘œí˜„ì‹ ë¬´íš¨í™”
    this.invalidateExpressionCache(name);
  }
}
```

### ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§

```typescript
class PerformanceProfiler {
  private metrics: Map<string, PerformanceMetric> = new Map();
  
  public startTimer(name: string): void {
    this.metrics.set(name, {
      startTime: performance.now(),
      endTime: 0,
      duration: 0,
      callCount: (this.metrics.get(name)?.callCount || 0) + 1
    });
  }
  
  public endTimer(name: string): number {
    const metric = this.metrics.get(name);
    if (!metric) return 0;
    
    metric.endTime = performance.now();
    metric.duration = metric.endTime - metric.startTime;
    
    return metric.duration;
  }
  
  public getReport(): PerformanceReport {
    const report: PerformanceReport = {
      totalTime: 0,
      breakdown: new Map()
    };
    
    for (const [name, metric] of this.metrics) {
      report.breakdown.set(name, {
        totalTime: metric.duration * metric.callCount,
        averageTime: metric.duration / metric.callCount,
        callCount: metric.callCount
      });
      
      report.totalTime += metric.duration * metric.callCount;
    }
    
    return report;
  }
}
```

## ğŸ”„ í™•ì¥ì„± ì„¤ê³„

### í”ŒëŸ¬ê·¸ì¸ ì•„í‚¤í…ì²˜

```typescript
interface Plugin {
  readonly name: string;
  readonly version: string;
  readonly dependencies: string[];
  
  initialize(context: PluginContext): Promise<void>;
  destroy(): Promise<void>;
}

interface PluginContext {
  cpu: CPU6502;
  interpreter: BasicInterpreter;
  ui: UIManager;
  eventBus: EventBus;
}

class PluginManager {
  private plugins = new Map<string, Plugin>();
  private loadedPlugins = new Set<string>();
  
  public async loadPlugin(plugin: Plugin): Promise<void> {
    // ì˜ì¡´ì„± í™•ì¸
    for (const dep of plugin.dependencies) {
      if (!this.loadedPlugins.has(dep)) {
        throw new PluginError(`Dependency not found: ${dep}`);
      }
    }
    
    // í”ŒëŸ¬ê·¸ì¸ ì´ˆê¸°í™”
    const context = this.createPluginContext();
    await plugin.initialize(context);
    
    this.plugins.set(plugin.name, plugin);
    this.loadedPlugins.add(plugin.name);
  }
  
  public async unloadPlugin(name: string): Promise<void> {
    const plugin = this.plugins.get(name);
    if (!plugin) return;
    
    // ì˜ì¡´ì„± í™•ì¸ (ë‹¤ë¥¸ í”ŒëŸ¬ê·¸ì¸ì´ ì˜ì¡´í•˜ê³  ìˆëŠ”ì§€)
    for (const [, otherPlugin] of this.plugins) {
      if (otherPlugin.dependencies.includes(name)) {
        throw new PluginError(`Cannot unload ${name}: still has dependents`);
      }
    }
    
    await plugin.destroy();
    this.plugins.delete(name);
    this.loadedPlugins.delete(name);
  }
}
```

### ë‹¤ì¤‘ í”Œë«í¼ ì§€ì›

```typescript
// í”Œë«í¼ë³„ ì¶”ìƒí™”
interface PlatformAdapter {
  readonly name: string;
  readonly memoryLayout: MemoryLayout;
  readonly ioMapping: IOMapping;
  
  initialize(): void;
  handleInterrupt(type: InterruptType): void;
  getSystemInfo(): SystemInfo;
}

// Apple II í”Œë«í¼
class Apple2Adapter implements PlatformAdapter {
  readonly name = 'Apple II';
  readonly memoryLayout = {
    textPage: 0x400,
    hires: 0x2000,
    rom: 0xD000
  };
  readonly ioMapping = {
    keyboard: 0xC000,
    speaker: 0xC030,
    graphics: 0xC050
  };
  
  initialize(): void {
    // Apple II íŠ¹í™” ì´ˆê¸°í™”
    this.setupTextMode();
    this.initializeKeyboard();
  }
  
  handleInterrupt(type: InterruptType): void {
    // Apple II ì¸í„°ëŸ½íŠ¸ ì²˜ë¦¬
  }
}

// í”Œë«í¼ ê´€ë¦¬ì
class PlatformManager {
  private currentAdapter?: PlatformAdapter;
  private adapters = new Map<string, PlatformAdapter>();
  
  public registerAdapter(adapter: PlatformAdapter): void {
    this.adapters.set(adapter.name, adapter);
  }
  
  public switchPlatform(name: string): void {
    const adapter = this.adapters.get(name);
    if (!adapter) {
      throw new Error(`Unknown platform: ${name}`);
    }
    
    if (this.currentAdapter) {
      // í˜„ì¬ í”Œë«í¼ ì •ë¦¬
    }
    
    this.currentAdapter = adapter;
    adapter.initialize();
    
    // CPUì™€ ë©”ëª¨ë¦¬ ì¬êµ¬ì„±
    this.reconfigureSystem(adapter);
  }
}
```

## ğŸ›¡ï¸ ë³´ì•ˆ ê³ ë ¤ì‚¬í•­

### ë©”ëª¨ë¦¬ ë³´í˜¸

```typescript
class SecureMemoryManager extends MemoryManager {
  private readonly protectedRanges: MemoryRange[] = [];
  private readonly readOnlyRanges: MemoryRange[] = [];
  
  public addProtectedRange(start: number, end: number): void {
    this.protectedRanges.push({ start, end });
  }
  
  public addReadOnlyRange(start: number, end: number): void {
    this.readOnlyRanges.push({ start, end });
  }
  
  public write(address: number, value: number): void {
    // ë³´í˜¸ëœ ë©”ëª¨ë¦¬ ì˜ì—­ í™•ì¸
    for (const range of this.protectedRanges) {
      if (address >= range.start && address <= range.end) {
        throw new MemoryProtectionError(
          `Access denied to protected memory at 0x${address.toString(16)}`
        );
      }
    }
    
    // ì½ê¸° ì „ìš© ì˜ì—­ í™•ì¸
    for (const range of this.readOnlyRanges) {
      if (address >= range.start && address <= range.end) {
        throw new MemoryProtectionError(
          `Attempt to write to read-only memory at 0x${address.toString(16)}`
        );
      }
    }
    
    super.write(address, value);
  }
}
```

### ì…ë ¥ ê²€ì¦

```typescript
class InputValidator {
  public static validateBasicLine(line: string): ValidationResult {
    // ê¸¸ì´ ì œí•œ
    if (line.length > MAX_LINE_LENGTH) {
      return { valid: false, error: 'Line too long' };
    }
    
    // ìœ„í—˜í•œ íŒ¨í„´ ê²€ì‚¬
    const dangerousPatterns = [
      /eval\s*\(/i,
      /function\s*\(/i,
      /<script/i,
      /javascript:/i
    ];
    
    for (const pattern of dangerousPatterns) {
      if (pattern.test(line)) {
        return { valid: false, error: 'Potentially unsafe content detected' };
      }
    }
    
    return { valid: true };
  }
  
  public static sanitizeFilename(filename: string): string {
    // ê²½ë¡œ ìˆœíšŒ ë°©ì§€
    return filename
      .replace(/[\/\\]/g, '') // ê²½ë¡œ êµ¬ë¶„ì ì œê±°
      .replace(/\.\./g, '')   // ìƒìœ„ ë””ë ‰í† ë¦¬ ì°¸ì¡° ì œê±°
      .replace(/[<>:"|?*]/g, '') // íŠ¹ìˆ˜ ë¬¸ì ì œê±°
      .substring(0, 255);     // ê¸¸ì´ ì œí•œ
  }
}
```

### ìƒŒë“œë°•ìŠ¤ ì‹¤í–‰

```typescript
class SandboxedInterpreter extends BasicInterpreter {
  private readonly maxExecutionTime = 30000; // 30ì´ˆ
  private readonly maxMemoryUsage = 50 * 1024 * 1024; // 50MB
  private executionStartTime = 0;
  
  public async executeProgram(program: Program): Promise<ExecutionResult> {
    this.executionStartTime = performance.now();
    
    // ì‹¤í–‰ ì‹œê°„ ëª¨ë‹ˆí„°ë§
    const timeoutId = setTimeout(() => {
      throw new ExecutionTimeoutError('Program execution timeout');
    }, this.maxExecutionTime);
    
    try {
      // ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ëª¨ë‹ˆí„°ë§
      this.startMemoryMonitoring();
      
      const result = await super.executeProgram(program);
      
      clearTimeout(timeoutId);
      return result;
      
    } catch (error) {
      clearTimeout(timeoutId);
      throw error;
    }
  }
  
  private startMemoryMonitoring(): void {
    const checkMemory = () => {
      const memoryUsage = this.getMemoryUsage();
      if (memoryUsage > this.maxMemoryUsage) {
        throw new MemoryLimitError('Memory usage limit exceeded');
      }
      
      if (performance.now() - this.executionStartTime < this.maxExecutionTime) {
        setTimeout(checkMemory, 1000); // 1ì´ˆë§ˆë‹¤ í™•ì¸
      }
    };
    
    setTimeout(checkMemory, 1000);
  }
}
```

ì´ ì•„í‚¤í…ì²˜ ë¬¸ì„œë¥¼ í†µí•´ 6502 BASIC JavaScript ì—ë®¬ë ˆì´í„°ì˜ ì „ì²´ì ì¸ êµ¬ì¡°ì™€ ì„¤ê³„ ì² í•™ì„ ì´í•´í•˜ê³ , ê° ëª¨ë“ˆ ê°„ì˜ ìƒí˜¸ì‘ìš©ê³¼ í™•ì¥ ë°©ë²•ì„ íŒŒì•…í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.